# generated by datamodel-codegen:
#   filename:  https://github.com/CycloneDX/specification/raw/refs/tags/1.6/schema/bom-1.5.schema.json
#   timestamp: 2024-10-02T15:54:54+00:00

from __future__ import annotations

from enum import Enum
from typing import Annotated, Optional, Union

from pydantic import AnyUrl, AwareDatetime, BaseModel, ConfigDict, EmailStr, Field, RootModel

from . import spdx


class FieldSchema(str, Enum):
    http___cyclonedx_org_schema_bom_1_5_schema_json = (
        "http://cyclonedx.org/schema/bom-1.5.schema.json"
    )


class BomFormat(str, Enum):
    """
    Specifies the format of the BOM. This helps to identify the file as CycloneDX since BOMs do not have a filename convention nor does JSON schema support namespaces. This value MUST be "CycloneDX".
    """

    CycloneDX = "CycloneDX"


class RefType(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="Identifier for referable and therefore interlink-able elements.",
            min_length=1,
        ),
    ]


class RefLinkType(BaseModel):
    """
    Descriptor for an element identified by the attribute 'bom-ref' in the same BOM document.
    In contrast to `bomLinkElementType`.
    """


class BomLinkDocumentType(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="Descriptor for another BOM document. See https://cyclonedx.org/capabilities/bomlink/",
            pattern="^urn:cdx:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/[1-9][0-9]*$",
            title="BOM-Link Document",
        ),
    ]


class BomLinkElementType(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="Descriptor for an element in a BOM document. See https://cyclonedx.org/capabilities/bomlink/",
            pattern="^urn:cdx:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/[1-9][0-9]*#.+$",
            title="BOM-Link Element",
        ),
    ]


class BomLink(RootModel[Union[BomLinkDocumentType, BomLinkElementType]]):
    root: Union[BomLinkDocumentType, BomLinkElementType]


class Phase(str, Enum):
    """
    A pre-defined phase in the product lifecycle.

    * __design__ = BOM produced early in the development lifecycle containing inventory of components and services that are proposed or planned to be used. The inventory may need to be procured, retrieved, or resourced prior to use.
    * __pre-build__ = BOM consisting of information obtained prior to a build process and may contain source files and development artifacts and manifests. The inventory may need to be resolved and retrieved prior to use.
    * __build__ = BOM consisting of information obtained during a build process where component inventory is available for use. The precise versions of resolved components are usually available at this time as well as the provenance of where the components were retrieved from.
    * __post-build__ = BOM consisting of information obtained after a build process has completed and the resulting components(s) are available for further analysis. Built components may exist as the result of a CI/CD process, may have been installed or deployed to a system or device, and may need to be retrieved or extracted from the system or device.
    * __operations__ = BOM produced that represents inventory that is running and operational. This may include staging or production environments and will generally encompass multiple SBOMs describing the applications and operating system, along with HBOMs describing the hardware that makes up the system. Operations Bill of Materials (OBOM) can provide full-stack inventory of runtime environments, configurations, and additional dependencies.
    * __discovery__ = BOM consisting of information observed through network discovery providing point-in-time enumeration of embedded, on-premise, and cloud-native services such as server applications, connected devices, microservices, and serverless functions.
    * __decommission__ = BOM containing inventory that will be, or has been retired from operations.
    """

    design = "design"
    pre_build = "pre-build"
    build = "build"
    post_build = "post-build"
    operations = "operations"
    discovery = "discovery"
    decommission = "decommission"


class Lifecycles(BaseModel):
    """
    The product lifecycle(s) that this BOM represents.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    phase: Annotated[
        Phase,
        Field(
            description="A pre-defined phase in the product lifecycle.\n\n* __design__ = BOM produced early in the development lifecycle containing inventory of components and services that are proposed or planned to be used. The inventory may need to be procured, retrieved, or resourced prior to use.\n* __pre-build__ = BOM consisting of information obtained prior to a build process and may contain source files and development artifacts and manifests. The inventory may need to be resolved and retrieved prior to use.\n* __build__ = BOM consisting of information obtained during a build process where component inventory is available for use. The precise versions of resolved components are usually available at this time as well as the provenance of where the components were retrieved from.\n* __post-build__ = BOM consisting of information obtained after a build process has completed and the resulting components(s) are available for further analysis. Built components may exist as the result of a CI/CD process, may have been installed or deployed to a system or device, and may need to be retrieved or extracted from the system or device.\n* __operations__ = BOM produced that represents inventory that is running and operational. This may include staging or production environments and will generally encompass multiple SBOMs describing the applications and operating system, along with HBOMs describing the hardware that makes up the system. Operations Bill of Materials (OBOM) can provide full-stack inventory of runtime environments, configurations, and additional dependencies.\n* __discovery__ = BOM consisting of information observed through network discovery providing point-in-time enumeration of embedded, on-premise, and cloud-native services such as server applications, connected devices, microservices, and serverless functions.\n* __decommission__ = BOM containing inventory that will be, or has been retired from operations.",
            title="Phase",
        ),
    ]


class Lifecycles1(BaseModel):
    """
    The product lifecycle(s) that this BOM represents.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[str, Field(description="The name of the lifecycle phase", title="Name")]
    description: Annotated[
        Optional[str],
        Field(description="The description of the lifecycle phase", title="Description"),
    ] = None


class OrganizationalContact(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        Optional[RefType],
        Field(
            alias="bom-ref",
            description="An optional identifier which can be used to reference the object elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.",
            title="BOM Reference",
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(description="The name of a contact", examples=["Contact name"], title="Name"),
    ] = None
    email: Annotated[
        Optional[EmailStr],
        Field(
            description="The email address of the contact.",
            examples=["firstname.lastname@example.com"],
            title="Email Address",
        ),
    ] = None
    phone: Annotated[
        Optional[str],
        Field(
            description="The phone number of the contact.", examples=["800-555-1212"], title="Phone"
        ),
    ] = None


class Type(str, Enum):
    """
    Specifies the type of component. For software components, classify as application if no more specific appropriate classification is available or cannot be determined for the component. Types include:

    * __application__ = A software application. Refer to [https://en.wikipedia.org/wiki/Application_software](https://en.wikipedia.org/wiki/Application_software) for information about applications.
    * __framework__ = A software framework. Refer to [https://en.wikipedia.org/wiki/Software_framework](https://en.wikipedia.org/wiki/Software_framework) for information on how frameworks vary slightly from libraries.
    * __library__ = A software library. Refer to [https://en.wikipedia.org/wiki/Library_(computing)](https://en.wikipedia.org/wiki/Library_(computing))
     for information about libraries. All third-party and open source reusable components will likely be a library. If the library also has key features of a framework, then it should be classified as a framework. If not, or is unknown, then specifying library is RECOMMENDED.
    * __container__ = A packaging and/or runtime format, not specific to any particular technology, which isolates software inside the container from software outside of a container through virtualization technology. Refer to [https://en.wikipedia.org/wiki/OS-level_virtualization](https://en.wikipedia.org/wiki/OS-level_virtualization)
    * __platform__ = A runtime environment which interprets or executes software. This may include runtimes such as those that execute bytecode or low-code/no-code application platforms.
    * __operating-system__ = A software operating system without regard to deployment model (i.e. installed on physical hardware, virtual machine, image, etc) Refer to [https://en.wikipedia.org/wiki/Operating_system](https://en.wikipedia.org/wiki/Operating_system)
    * __device__ = A hardware device such as a processor, or chip-set. A hardware device containing firmware SHOULD include a component for the physical hardware itself, and another component of type 'firmware' or 'operating-system' (whichever is relevant), describing information about the software running on the device.
      See also the list of [known device properties](https://github.com/CycloneDX/cyclonedx-property-taxonomy/blob/main/cdx/device.md).
    * __device-driver__ = A special type of software that operates or controls a particular type of device. Refer to [https://en.wikipedia.org/wiki/Device_driver](https://en.wikipedia.org/wiki/Device_driver)
    * __firmware__ = A special type of software that provides low-level control over a devices hardware. Refer to [https://en.wikipedia.org/wiki/Firmware](https://en.wikipedia.org/wiki/Firmware)
    * __file__ = A computer file. Refer to [https://en.wikipedia.org/wiki/Computer_file](https://en.wikipedia.org/wiki/Computer_file) for information about files.
    * __machine-learning-model__ = A model based on training data that can make predictions or decisions without being explicitly programmed to do so.
    * __data__ = A collection of discrete values that convey information.
    """

    application = "application"
    framework = "framework"
    library = "library"
    container = "container"
    platform = "platform"
    operating_system = "operating-system"
    device = "device"
    device_driver = "device-driver"
    firmware = "firmware"
    file = "file"
    machine_learning_model = "machine-learning-model"
    data = "data"


class Scope(str, Enum):
    """
    Specifies the scope of the component. If scope is not specified, 'required' scope SHOULD be assumed by the consumer of the BOM.
    """

    required = "required"
    optional = "optional"
    excluded = "excluded"


class Encoding(str, Enum):
    """
    Specifies the optional encoding the text is represented in.
    """

    base64 = "base64"


class Attachment(BaseModel):
    """
    Specifies the metadata and content for an attachment.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    contentType: Annotated[
        Optional[str],
        Field(
            description="Specifies the content type of the text. Defaults to text/plain if not specified.",
            title="Content-Type",
        ),
    ] = "text/plain"
    encoding: Annotated[
        Optional[Encoding],
        Field(
            description="Specifies the optional encoding the text is represented in.",
            title="Encoding",
        ),
    ] = None
    content: Annotated[
        str,
        Field(
            description="The attachment data. Proactive controls such as input validation and sanitization should be employed to prevent misuse of attachment text.",
            title="Attachment Text",
        ),
    ]


class HashAlg(str, Enum):
    MD5 = "MD5"
    SHA_1 = "SHA-1"
    SHA_256 = "SHA-256"
    SHA_384 = "SHA-384"
    SHA_512 = "SHA-512"
    SHA3_256 = "SHA3-256"
    SHA3_384 = "SHA3-384"
    SHA3_512 = "SHA3-512"
    BLAKE2b_256 = "BLAKE2b-256"
    BLAKE2b_384 = "BLAKE2b-384"
    BLAKE2b_512 = "BLAKE2b-512"
    BLAKE3 = "BLAKE3"


class HashContent(RootModel[str]):
    root: Annotated[
        str,
        Field(
            examples=["3942447fac867ae5cdb3229b658f4d48"],
            pattern="^([a-fA-F0-9]{32}|[a-fA-F0-9]{40}|[a-fA-F0-9]{64}|[a-fA-F0-9]{96}|[a-fA-F0-9]{128})$",
            title="Hash Content (value)",
        ),
    ]


class LicenseType(str, Enum):
    academic = "academic"
    appliance = "appliance"
    client_access = "client-access"
    concurrent_user = "concurrent-user"
    core_points = "core-points"
    custom_metric = "custom-metric"
    device = "device"
    evaluation = "evaluation"
    named_user = "named-user"
    node_locked = "node-locked"
    oem = "oem"
    perpetual = "perpetual"
    processor_points = "processor-points"
    subscription = "subscription"
    user = "user"
    other = "other"


class LicenseChoice(RootModel[list]):
    """
    EITHER (list of SPDX licenses and/or named licenses) OR (tuple of one SPDX License Expression)
    """

    root: Annotated[
        list,
        Field(
            description="EITHER (list of SPDX licenses and/or named licenses) OR (tuple of one SPDX License Expression)",
            title="License Choice",
        ),
    ]


class Type1(str, Enum):
    """
    Specifies the purpose for the patch including the resolution of defects, security issues, or new behavior or functionality.

    * __unofficial__ = A patch which is not developed by the creators or maintainers of the software being patched. Refer to [https://en.wikipedia.org/wiki/Unofficial_patch](https://en.wikipedia.org/wiki/Unofficial_patch)
    * __monkey__ = A patch which dynamically modifies runtime behavior. Refer to [https://en.wikipedia.org/wiki/Monkey_patch](https://en.wikipedia.org/wiki/Monkey_patch)
    * __backport__ = A patch which takes code from a newer version of software and applies it to older versions of the same software. Refer to [https://en.wikipedia.org/wiki/Backporting](https://en.wikipedia.org/wiki/Backporting)
    * __cherry-pick__ = A patch created by selectively applying commits from other versions or branches of the same software.
    """

    unofficial = "unofficial"
    monkey = "monkey"
    backport = "backport"
    cherry_pick = "cherry-pick"


class Diff(BaseModel):
    """
    The patch file (or diff) that show changes. Refer to https://en.wikipedia.org/wiki/Diff
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    text: Annotated[
        Optional[Attachment],
        Field(description="Specifies the optional text of the diff", title="Diff text"),
    ] = None
    url: Annotated[
        Optional[str], Field(description="Specifies the URL to the diff", title="URL")
    ] = None


class Type2(str, Enum):
    """
    Specifies the type of issue
    """

    defect = "defect"
    enhancement = "enhancement"
    security = "security"


class Source(BaseModel):
    """
    The source of the issue where it is documented
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[
        Optional[str],
        Field(
            description="The name of the source. For example 'National Vulnerability Database', 'NVD', and 'Apache'",
            title="Name",
        ),
    ] = None
    url: Annotated[
        Optional[str],
        Field(
            description="The url of the issue documentation as provided by the source", title="URL"
        ),
    ] = None


class Issue(BaseModel):
    """
    An individual issue that has been resolved.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    type: Annotated[Type2, Field(description="Specifies the type of issue", title="Type")]
    id: Annotated[
        Optional[str],
        Field(
            description="The identifier of the issue assigned by the source of the issue",
            title="ID",
        ),
    ] = None
    name: Annotated[Optional[str], Field(description="The name of the issue", title="Name")] = None
    description: Annotated[
        Optional[str], Field(description="A description of the issue", title="Description")
    ] = None
    source: Annotated[
        Optional[Source],
        Field(description="The source of the issue where it is documented", title="Source"),
    ] = None
    references: Annotated[
        Optional[list[str]],
        Field(
            description="A collection of URL's for reference. Multiple URLs are allowed.",
            examples=["https://example.com"],
            title="References",
        ),
    ] = None


class IdentifiableAction(BaseModel):
    """
    Specifies an individual commit
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    timestamp: Annotated[
        Optional[AwareDatetime],
        Field(description="The timestamp in which the action occurred", title="Timestamp"),
    ] = None
    name: Annotated[
        Optional[str],
        Field(description="The name of the individual who performed the action", title="Name"),
    ] = None
    email: Annotated[
        Optional[EmailStr],
        Field(
            description="The email address of the individual who performed the action",
            title="E-mail",
        ),
    ] = None


class Type3(str, Enum):
    """
    Specifies the type of external reference.

    * __vcs__ = Version Control System
    * __issue-tracker__ = Issue or defect tracking system, or an Application Lifecycle Management (ALM) system
    * __website__ = Website
    * __advisories__ = Security advisories
    * __bom__ = Bill of Materials (SBOM, OBOM, HBOM, SaaSBOM, etc)
    * __mailing-list__ = Mailing list or discussion group
    * __social__ = Social media account
    * __chat__ = Real-time chat platform
    * __documentation__ = Documentation, guides, or how-to instructions
    * __support__ = Community or commercial support
    * __distribution__ = Direct or repository download location
    * __distribution-intake__ = The location where a component was published to. This is often the same as "distribution" but may also include specialized publishing processes that act as an intermediary
    * __license__ = The URL to the license file. If a license URL has been defined in the license node, it should also be defined as an external reference for completeness
    * __build-meta__ = Build-system specific meta file (i.e. pom.xml, package.json, .nuspec, etc)
    * __build-system__ = URL to an automated build system
    * __release-notes__ = URL to release notes
    * __security-contact__ = Specifies a way to contact the maintainer, supplier, or provider in the event of a security incident. Common URIs include links to a disclosure procedure, a mailto (RFC-2368) that specifies an email address, a tel (RFC-3966) that specifies a phone number, or dns (RFC-4501) that specifies the records containing DNS Security TXT
    * __model-card__ = A model card describes the intended uses of a machine learning model, potential limitations, biases, ethical considerations, training parameters, datasets used to train the model, performance metrics, and other relevant data useful for ML transparency
    * __log__ = A record of events that occurred in a computer system or application, such as problems, errors, or information on current operations
    * __configuration__ = Parameters or settings that may be used by other components or services
    * __evidence__ = Information used to substantiate a claim
    * __formulation__ = Describes how a component or service was manufactured or deployed
    * __attestation__ = Human or machine-readable statements containing facts, evidence, or testimony
    * __threat-model__ = An enumeration of identified weaknesses, threats, and countermeasures, dataflow diagram (DFD), attack tree, and other supporting documentation in human-readable or machine-readable format
    * __adversary-model__ = The defined assumptions, goals, and capabilities of an adversary.
    * __risk-assessment__ = Identifies and analyzes the potential of future events that may negatively impact individuals, assets, and/or the environment. Risk assessments may also include judgments on the tolerability of each risk.
    * __vulnerability-assertion__ = A Vulnerability Disclosure Report (VDR) which asserts the known and previously unknown vulnerabilities that affect a component, service, or product including the analysis and findings describing the impact (or lack of impact) that the reported vulnerability has on a component, service, or product.
    * __exploitability-statement__ = A Vulnerability Exploitability eXchange (VEX) which asserts the known vulnerabilities that do not affect a product, product family, or organization, and optionally the ones that do. The VEX should include the analysis and findings describing the impact (or lack of impact) that the reported vulnerability has on the product, product family, or organization.
    * __pentest-report__ = Results from an authorized simulated cyberattack on a component or service, otherwise known as a penetration test
    * __static-analysis-report__ = SARIF or proprietary machine or human-readable report for which static analysis has identified code quality, security, and other potential issues with the source code
    * __dynamic-analysis-report__ = Dynamic analysis report that has identified issues such as vulnerabilities and misconfigurations
    * __runtime-analysis-report__ = Report generated by analyzing the call stack of a running application
    * __component-analysis-report__ = Report generated by Software Composition Analysis (SCA), container analysis, or other forms of component analysis
    * __maturity-report__ = Report containing a formal assessment of an organization, business unit, or team against a maturity model
    * __certification-report__ = Industry, regulatory, or other certification from an accredited (if applicable) certification body
    * __quality-metrics__ = Report or system in which quality metrics can be obtained
    * __codified-infrastructure__ = Code or configuration that defines and provisions virtualized infrastructure, commonly referred to as Infrastructure as Code (IaC)
    * __poam__ = Plans of Action and Milestones (POAM) compliment an "attestation" external reference. POAM is defined by NIST as a "document that identifies tasks needing to be accomplished. It details resources required to accomplish the elements of the plan, any milestones in meeting the tasks and scheduled completion dates for the milestones".
    * __other__ = Use this if no other types accurately describe the purpose of the external reference
    """

    vcs = "vcs"
    issue_tracker = "issue-tracker"
    website = "website"
    advisories = "advisories"
    bom = "bom"
    mailing_list = "mailing-list"
    social = "social"
    chat = "chat"
    documentation = "documentation"
    support = "support"
    distribution = "distribution"
    distribution_intake = "distribution-intake"
    license = "license"
    build_meta = "build-meta"
    build_system = "build-system"
    release_notes = "release-notes"
    security_contact = "security-contact"
    model_card = "model-card"
    log = "log"
    configuration = "configuration"
    evidence = "evidence"
    formulation = "formulation"
    attestation = "attestation"
    threat_model = "threat-model"
    adversary_model = "adversary-model"
    risk_assessment = "risk-assessment"
    vulnerability_assertion = "vulnerability-assertion"
    exploitability_statement = "exploitability-statement"
    pentest_report = "pentest-report"
    static_analysis_report = "static-analysis-report"
    dynamic_analysis_report = "dynamic-analysis-report"
    runtime_analysis_report = "runtime-analysis-report"
    component_analysis_report = "component-analysis-report"
    maturity_report = "maturity-report"
    certification_report = "certification-report"
    codified_infrastructure = "codified-infrastructure"
    quality_metrics = "quality-metrics"
    poam = "poam"
    other = "other"


class Dependency(BaseModel):
    """
    Defines the direct dependencies of a component or service. Components or services that do not have their own dependencies MUST be declared as empty elements within the graph. Components or services that are not represented in the dependency graph MAY have unknown dependencies. It is RECOMMENDED that implementations assume this to be opaque and not an indicator of a object being dependency-free. It is RECOMMENDED to leverage compositions to indicate unknown dependency graphs.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    ref: Annotated[
        RefLinkType,
        Field(
            description="References a component or service by its bom-ref attribute",
            title="Reference",
        ),
    ]
    dependsOn: Annotated[
        Optional[list[RefLinkType]],
        Field(
            description="The bom-ref identifiers of the components or services that are dependencies of this dependency object.",
            title="Depends On",
        ),
    ] = None


class DataFlowDirection(str, Enum):
    """
    Specifies the flow direction of the data. Direction is relative to the service. Inbound flow states that data enters the service. Outbound flow states that data leaves the service. Bi-directional states that data flows both ways, and unknown states that the direction is not known.
    """

    inbound = "inbound"
    outbound = "outbound"
    bi_directional = "bi-directional"
    unknown = "unknown"


class Copyright(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    text: Annotated[str, Field(title="Copyright Text")]


class FieldModel(str, Enum):
    """
    The identity field of the component which the evidence describes.
    """

    group = "group"
    name = "name"
    version = "version"
    purl = "purl"
    cpe = "cpe"
    swid = "swid"
    hash = "hash"


class Technique(str, Enum):
    """
    The technique used in this method of analysis.
    """

    source_code_analysis = "source-code-analysis"
    binary_analysis = "binary-analysis"
    manifest_analysis = "manifest-analysis"
    ast_fingerprint = "ast-fingerprint"
    hash_comparison = "hash-comparison"
    instrumentation = "instrumentation"
    dynamic_analysis = "dynamic-analysis"
    filename = "filename"
    attestation = "attestation"
    other = "other"


class Method(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    technique: Annotated[
        Technique,
        Field(description="The technique used in this method of analysis.", title="Technique"),
    ]
    confidence: Annotated[
        float,
        Field(
            description="The confidence of the evidence from 0 - 1, where 1 is 100% confidence. Confidence is specific to the technique used. Each technique of analysis can have independent confidence.",
            ge=0.0,
            le=1.0,
            title="Confidence",
        ),
    ]
    value: Annotated[
        Optional[str], Field(description="The value or contents of the evidence.", title="Value")
    ] = None


class Identity(BaseModel):
    """
    Evidence that substantiates the identity of a component.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    field: Annotated[
        FieldModel,
        Field(
            description="The identity field of the component which the evidence describes.",
            title="Field",
        ),
    ]
    confidence: Annotated[
        Optional[float],
        Field(
            description="The overall confidence of the evidence from 0 - 1, where 1 is 100% confidence.",
            ge=0.0,
            le=1.0,
            title="Confidence",
        ),
    ] = None
    methods: Annotated[
        Optional[list[Method]],
        Field(
            description="The methods used to extract and/or analyze the evidence.", title="Methods"
        ),
    ] = None
    tools: Annotated[
        Optional[list[Union[RefLinkType, BomLinkElementType]]],
        Field(
            description="The object in the BOM identified by its bom-ref. This is often a component or service, but may be any object type supporting bom-refs. Tools used for analysis should already be defined in the BOM, either in the metadata/tools, components, or formulation.",
            title="BOM References",
        ),
    ] = None


class Occurrence(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        Optional[RefType],
        Field(
            alias="bom-ref",
            description="An optional identifier which can be used to reference the occurrence elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.",
            title="BOM Reference",
        ),
    ] = None
    location: Annotated[
        str,
        Field(
            description="The location or path to where the component was found.", title="Location"
        ),
    ]


class Frame(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    package: Annotated[
        Optional[str],
        Field(
            description="A package organizes modules into namespaces, providing a unique namespace for each type it contains.",
            title="Package",
        ),
    ] = None
    module: Annotated[
        str,
        Field(
            description="A module or class that encloses functions/methods and other code.",
            title="Module",
        ),
    ]
    function: Annotated[
        Optional[str],
        Field(
            description="A block of code designed to perform a particular task.", title="Function"
        ),
    ] = None
    parameters: Annotated[
        Optional[list[str]],
        Field(
            description="Optional arguments that are passed to the module or function.",
            title="Parameters",
        ),
    ] = None
    line: Annotated[
        Optional[int],
        Field(description="The line number the code that is called resides on.", title="Line"),
    ] = None
    column: Annotated[
        Optional[int],
        Field(description="The column the code that is called resides.", title="Column"),
    ] = None
    fullFilename: Annotated[
        Optional[str],
        Field(description="The full path and filename of the module.", title="Full Filename"),
    ] = None


class Callstack(BaseModel):
    """
    Evidence of the components use through the callstack.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    frames: Annotated[Optional[list[Frame]], Field(title="Methods")] = None


class ComponentEvidence(BaseModel):
    """
    Provides the ability to document evidence collected through various forms of extraction or analysis.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    identity: Annotated[
        Optional[Identity],
        Field(description="Evidence that substantiates the identity of a component."),
    ] = None
    occurrences: Annotated[
        Optional[list[Occurrence]],
        Field(
            description="Evidence of individual instances of a component spread across multiple locations.",
            title="Occurrences",
        ),
    ] = None
    callstack: Annotated[
        Optional[Callstack],
        Field(description="Evidence of the components use through the callstack."),
    ] = None
    licenses: Annotated[Optional[LicenseChoice], Field(title="Component License(s)")] = None
    copyright: Annotated[Optional[list[Copyright]], Field(title="Copyright")] = None


class AggregateType(str, Enum):
    complete = "complete"
    incomplete = "incomplete"
    incomplete_first_party_only = "incomplete_first_party_only"
    incomplete_first_party_proprietary_only = "incomplete_first_party_proprietary_only"
    incomplete_first_party_opensource_only = "incomplete_first_party_opensource_only"
    incomplete_third_party_only = "incomplete_third_party_only"
    incomplete_third_party_proprietary_only = "incomplete_third_party_proprietary_only"
    incomplete_third_party_opensource_only = "incomplete_third_party_opensource_only"
    unknown = "unknown"
    not_specified = "not_specified"


class Property(BaseModel):
    """
    Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is OPTIONAL.
    """

    name: Annotated[
        Optional[str],
        Field(
            description="The name of the property. Duplicate names are allowed, each potentially having a different value.",
            title="Name",
        ),
    ] = None
    value: Annotated[
        Optional[str], Field(description="The value of the property.", title="Value")
    ] = None


class LocaleType(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="Defines a syntax for representing two character language code (ISO-639) followed by an optional two character country code. The language code MUST be lower case. If the country code is specified, the country code MUST be upper case. The language code and country code MUST be separated by a minus sign. Examples: en, en-US, fr, fr-CA",
            pattern="^([a-z]{2})(-[A-Z]{2})?$",
            title="Locale",
        ),
    ]


class ReleaseType(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="The software versioning type. It is RECOMMENDED that the release type use one of 'major', 'minor', 'patch', 'pre-release', or 'internal'. Representing all possible software release types is not practical, so standardizing on the recommended values, whenever possible, is strongly encouraged.\n\n* __major__ = A major release may contain significant changes or may introduce breaking changes.\n* __minor__ = A minor release, also known as an update, may contain a smaller number of changes than major releases.\n* __patch__ = Patch releases are typically unplanned and may resolve defects or important security issues.\n* __pre-release__ = A pre-release may include alpha, beta, or release candidates and typically have limited support. They provide the ability to preview a release prior to its general availability.\n* __internal__ = Internal releases are not for public consumption and are intended to be used exclusively by the project or manufacturer that produced it.",
            examples=["major", "minor", "patch", "pre-release", "internal"],
        ),
    ]


class Note(BaseModel):
    """
    A note containing the locale and content.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    locale: Annotated[
        Optional[LocaleType],
        Field(
            description='The ISO-639 (or higher) language code and optional ISO-3166 (or higher) country code. Examples include: "en", "en-US", "fr" and "fr-CA"',
            title="Locale",
        ),
    ] = None
    text: Annotated[
        Attachment,
        Field(
            description="Specifies the full content of the release note.",
            title="Release note content",
        ),
    ]


class ReleaseNotes(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Annotated[
        ReleaseType,
        Field(description="The software versioning type the release note describes.", title="Type"),
    ]
    title: Annotated[
        Optional[str], Field(description="The title of the release.", title="Title")
    ] = None
    featuredImage: Annotated[
        Optional[str],
        Field(
            description="The URL to an image that may be prominently displayed with the release note.",
            title="Featured image",
        ),
    ] = None
    socialImage: Annotated[
        Optional[str],
        Field(
            description="The URL to an image that may be used in messaging on social media platforms.",
            title="Social image",
        ),
    ] = None
    description: Annotated[
        Optional[str], Field(description="A short description of the release.", title="Description")
    ] = None
    timestamp: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The date and time (timestamp) when the release note was created.",
            title="Timestamp",
        ),
    ] = None
    aliases: Annotated[
        Optional[list[str]],
        Field(
            description="One or more alternate names the release may be referred to. This may include unofficial terms used by development and marketing teams (e.g. code names).",
            title="Aliases",
        ),
    ] = None
    tags: Annotated[
        Optional[list[str]],
        Field(
            description="One or more tags that may aid in search or retrieval of the release note.",
            title="Tags",
        ),
    ] = None
    resolves: Annotated[
        Optional[list[Issue]],
        Field(description="A collection of issues that have been resolved.", title="Resolves"),
    ] = None
    notes: Annotated[
        Optional[list[Note]],
        Field(
            description="Zero or more release notes containing the locale and content. Multiple note objects may be specified to support release notes in a wide variety of languages.",
            title="Notes",
        ),
    ] = None
    properties: Annotated[
        Optional[list[Property]],
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is OPTIONAL.",
            title="Properties",
        ),
    ] = None


class Advisory(BaseModel):
    """
    Title and location where advisory information can be obtained. An advisory is a notification of a threat to a component, service, or system.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    title: Annotated[
        Optional[str], Field(description="An optional name of the advisory.", title="Title")
    ] = None
    url: Annotated[
        str, Field(description="Location where the advisory can be obtained.", title="URL")
    ]


class Cwe(RootModel[int]):
    root: Annotated[
        int,
        Field(
            description="Integer representation of a Common Weaknesses Enumerations (CWE). For example 399 (of https://cwe.mitre.org/data/definitions/399.html)",
            ge=1,
            title="CWE",
        ),
    ]


class Severity(str, Enum):
    """
    Textual representation of the severity of the vulnerability adopted by the analysis method. If the analysis method uses values other than what is provided, the user is expected to translate appropriately.
    """

    critical = "critical"
    high = "high"
    medium = "medium"
    low = "low"
    info = "info"
    none = "none"
    unknown = "unknown"


class ScoreMethod(str, Enum):
    """
    Specifies the severity or risk scoring methodology or standard used.

    * CVSSv2 - [Common Vulnerability Scoring System v2](https://www.first.org/cvss/v2/)
    * CVSSv3 - [Common Vulnerability Scoring System v3](https://www.first.org/cvss/v3-0/)
    * CVSSv31 - [Common Vulnerability Scoring System v3.1](https://www.first.org/cvss/v3-1/)
    * CVSSv4 - [Common Vulnerability Scoring System v4](https://www.first.org/cvss/v4-0/)
    * OWASP - [OWASP Risk Rating Methodology](https://owasp.org/www-community/OWASP_Risk_Rating_Methodology)
    * SSVC - [Stakeholder Specific Vulnerability Categorization](https://github.com/CERTCC/SSVC) (all versions)
    """

    CVSSv2 = "CVSSv2"
    CVSSv3 = "CVSSv3"
    CVSSv31 = "CVSSv31"
    CVSSv4 = "CVSSv4"
    OWASP = "OWASP"
    SSVC = "SSVC"
    other = "other"


class ImpactAnalysisState(str, Enum):
    """
    Declares the current state of an occurrence of a vulnerability, after automated or manual analysis.

    * __resolved__ = the vulnerability has been remediated.
    * __resolved_with_pedigree__ = the vulnerability has been remediated and evidence of the changes are provided in the affected components pedigree containing verifiable commit history and/or diff(s).
    * __exploitable__ = the vulnerability may be directly or indirectly exploitable.
    * __in_triage__ = the vulnerability is being investigated.
    * __false_positive__ = the vulnerability is not specific to the component or service and was falsely identified or associated.
    * __not_affected__ = the component or service is not affected by the vulnerability. Justification should be specified for all not_affected cases.
    """

    resolved = "resolved"
    resolved_with_pedigree = "resolved_with_pedigree"
    exploitable = "exploitable"
    in_triage = "in_triage"
    false_positive = "false_positive"
    not_affected = "not_affected"


class ImpactAnalysisJustification(str, Enum):
    """
    The rationale of why the impact analysis state was asserted.

    * __code_not_present__ = the code has been removed or tree-shaked.
    * __code_not_reachable__ = the vulnerable code is not invoked at runtime.
    * __requires_configuration__ = exploitability requires a configurable option to be set/unset.
    * __requires_dependency__ = exploitability requires a dependency that is not present.
    * __requires_environment__ = exploitability requires a certain environment which is not present.
    * __protected_by_compiler__ = exploitability requires a compiler flag to be set/unset.
    * __protected_at_runtime__ = exploits are prevented at runtime.
    * __protected_at_perimeter__ = attacks are blocked at physical, logical, or network perimeter.
    * __protected_by_mitigating_control__ = preventative measures have been implemented that reduce the likelihood and/or impact of the vulnerability.
    """

    code_not_present = "code_not_present"
    code_not_reachable = "code_not_reachable"
    requires_configuration = "requires_configuration"
    requires_dependency = "requires_dependency"
    requires_environment = "requires_environment"
    protected_by_compiler = "protected_by_compiler"
    protected_at_runtime = "protected_at_runtime"
    protected_at_perimeter = "protected_at_perimeter"
    protected_by_mitigating_control = "protected_by_mitigating_control"


class VulnerabilitySource(BaseModel):
    """
    The source of vulnerability information. This is often the organization that published the vulnerability.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    url: Annotated[
        Optional[str],
        Field(
            description="The url of the vulnerability documentation as provided by the source.",
            examples=["https://nvd.nist.gov/vuln/detail/CVE-2021-39182"],
            title="URL",
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(
            description="The name of the source.",
            examples=[
                "NVD",
                "National Vulnerability Database",
                "OSS Index",
                "VulnDB",
                "GitHub Advisories",
            ],
            title="Name",
        ),
    ] = None


class Reference(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Annotated[
        str,
        Field(
            description="An identifier that uniquely identifies the vulnerability.",
            examples=["CVE-2021-39182", "GHSA-35m5-8cvj-8783", "SNYK-PYTHON-ENROCRYPT-1912876"],
            title="ID",
        ),
    ]
    source: Annotated[
        VulnerabilitySource, Field(description="The source that published the vulnerability.")
    ]


class ProofOfConcept(BaseModel):
    """
    Evidence used to reproduce the vulnerability.
    """

    reproductionSteps: Annotated[
        Optional[str],
        Field(
            description="Precise steps to reproduce the vulnerability.", title="Steps to Reproduce"
        ),
    ] = None
    environment: Annotated[
        Optional[str],
        Field(
            description="A description of the environment in which reproduction was possible.",
            title="Environment",
        ),
    ] = None
    supportingMaterial: Annotated[
        Optional[list[Attachment]],
        Field(
            description="Supporting material that helps in reproducing or understanding how reproduction is possible. This may include screenshots, payloads, and PoC exploit code.",
            title="Supporting Material",
        ),
    ] = None


class ResponseEnum(str, Enum):
    can_not_fix = "can_not_fix"
    will_not_fix = "will_not_fix"
    update = "update"
    rollback = "rollback"
    workaround_available = "workaround_available"


class Analysis(BaseModel):
    """
    An assessment of the impact and exploitability of the vulnerability.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    state: Optional[ImpactAnalysisState] = None
    justification: Optional[ImpactAnalysisJustification] = None
    response: Annotated[
        Optional[list[ResponseEnum]],
        Field(
            description="A response to the vulnerability by the manufacturer, supplier, or project responsible for the affected component or service. More than one response is allowed. Responses are strongly encouraged for vulnerabilities where the analysis state is exploitable.",
            title="Response",
        ),
    ] = None
    detail: Annotated[
        Optional[str],
        Field(
            description="Detailed description of the impact including methods used during assessment. If a vulnerability is not exploitable, this field should include specific details on why the component or service is not impacted by this vulnerability.",
            title="Detail",
        ),
    ] = None
    firstIssued: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The date and time (timestamp) when the analysis was first issued.",
            title="First Issued",
        ),
    ] = None
    lastUpdated: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The date and time (timestamp) when the analysis was last updated.",
            title="Last Updated",
        ),
    ] = None


class AffectedStatus(str, Enum):
    """
    The vulnerability status of a given version or range of versions of a product. The statuses 'affected' and 'unaffected' indicate that the version is affected or unaffected by the vulnerability. The status 'unknown' indicates that it is unknown or unspecified whether the given version is affected. There can be many reasons for an 'unknown' status, including that an investigation has not been undertaken or that a vendor has not disclosed the status.
    """

    affected = "affected"
    unaffected = "unaffected"
    unknown = "unknown"


class Version(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A single version of a component or service.", max_length=1024, min_length=1
        ),
    ]


class Range(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A version range specified in Package URL Version Range syntax (vers) which is defined at https://github.com/package-url/purl-spec/VERSION-RANGE-SPEC.rst",
            max_length=1024,
            min_length=1,
        ),
    ]


class Type4(str, Enum):
    """
    Learning types describing the learning problem or hybrid learning problem.
    """

    supervised = "supervised"
    unsupervised = "unsupervised"
    reinforcement_learning = "reinforcement-learning"
    semi_supervised = "semi-supervised"
    self_supervised = "self-supervised"


class Approach(BaseModel):
    """
    The overall approach to learning used by the model for problem solving.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    type: Annotated[
        Optional[Type4],
        Field(
            description="Learning types describing the learning problem or hybrid learning problem.",
            title="Learning Type",
        ),
    ] = None


class Datasets(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    ref: Annotated[
        Optional[Union[RefLinkType, BomLinkElementType]],
        Field(
            description="References a data component by the components bom-ref attribute",
            title="Reference",
        ),
    ] = None


class InputOutputMLParameters(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    format: Annotated[
        Optional[str],
        Field(
            description="The data format for input/output to the model. Example formats include string, image, time-series"
        ),
    ] = None


class Type5(str, Enum):
    """
    The general theme or subject matter of the data being specified.

    * __source-code__ = Any type of code, code snippet, or data-as-code.
    * __configuration__ = Parameters or settings that may be used by other components.
    * __dataset__ = A collection of data.
    * __definition__ = Data that can be used to create new instances of what the definition defines.
    * __other__ = Any other type of data that does not fit into existing definitions.
    """

    source_code = "source-code"
    configuration = "configuration"
    dataset = "dataset"
    definition = "definition"
    other = "other"


class Contents(BaseModel):
    """
    The contents or references to the contents of the data being described.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    attachment: Annotated[
        Optional[Attachment],
        Field(
            description="An optional way to include textual or encoded data.",
            title="Data Attachment",
        ),
    ] = None
    url: Annotated[
        Optional[str],
        Field(description="The URL to where the data can be retrieved.", title="Data URL"),
    ] = None
    properties: Annotated[
        Optional[list[Property]],
        Field(
            description="Provides the ability to document name-value parameters used for configuration.",
            title="Configuration Properties",
        ),
    ] = None


class Graphic(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[Optional[str], Field(description="The name of the graphic.")] = None
    image: Annotated[
        Optional[Attachment],
        Field(
            description="The graphic (vector or raster). Base64 encoding MUST be specified for binary images.",
            title="Graphic Image",
        ),
    ] = None


class ConfidenceInterval(BaseModel):
    """
    The confidence interval of the metric.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    lowerBound: Annotated[
        Optional[str], Field(description="The lower bound of the confidence interval.")
    ] = None
    upperBound: Annotated[
        Optional[str], Field(description="The upper bound of the confidence interval.")
    ] = None


class PerformanceMetric(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Annotated[Optional[str], Field(description="The type of performance metric.")] = None
    value: Annotated[Optional[str], Field(description="The value of the performance metric.")] = (
        None
    )
    slice: Annotated[
        Optional[str],
        Field(
            description="The name of the slice this metric was computed on. By default, assume this metric is not sliced."
        ),
    ] = None
    confidenceInterval: Annotated[
        Optional[ConfidenceInterval], Field(description="The confidence interval of the metric.")
    ] = None


class Risk(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[Optional[str], Field(description="The name of the risk.")] = None
    mitigationStrategy: Annotated[
        Optional[str], Field(description="Strategy used to address this risk.")
    ] = None


class FairnessAssessment(BaseModel):
    """
    Information about the benefits and harms of the model to an identified at risk group.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    groupAtRisk: Annotated[
        Optional[str],
        Field(
            description="The groups or individuals at risk of being systematically disadvantaged by the model."
        ),
    ] = None
    benefits: Annotated[
        Optional[str], Field(description="Expected benefits to the identified groups.")
    ] = None
    harms: Annotated[
        Optional[str], Field(description="Expected harms to the identified groups.")
    ] = None
    mitigationStrategy: Annotated[
        Optional[str],
        Field(
            description="With respect to the benefits and harms outlined, please describe any mitigation strategy implemented."
        ),
    ] = None


class DataClassification(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="Data classification tags data according to its type, sensitivity, and value if altered, stolen, or destroyed.",
            title="Data Classification",
        ),
    ]


class Command(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    executed: Annotated[
        Optional[str],
        Field(description="A text representation of the executed command.", title="Executed"),
    ] = None
    properties: Annotated[Optional[list[Property]], Field(title="Properties")] = None


class AccessMode(str, Enum):
    """
    Describes the read-write access control for the workspace relative to the owning resource instance.
    """

    read_only = "read-only"
    read_write = "read-write"
    read_write_once = "read-write-once"
    write_once = "write-once"
    write_only = "write-only"


class Mode(str, Enum):
    """
    The mode for the volume instance.
    """

    filesystem = "filesystem"
    block = "block"


class Volume(BaseModel):
    """
    An identifiable, logical unit of data storage tied to a physical device.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    uid: Annotated[
        Optional[str],
        Field(
            description="The unique identifier for the volume instance within its deployment context.",
            title="Unique Identifier (UID)",
        ),
    ] = None
    name: Annotated[
        Optional[str], Field(description="The name of the volume instance", title="Name")
    ] = None
    mode: Annotated[
        Optional[Mode], Field(description="The mode for the volume instance.", title="Mode")
    ] = "filesystem"
    path: Annotated[
        Optional[str],
        Field(description="The underlying path created from the actual volume.", title="Path"),
    ] = None
    sizeAllocated: Annotated[
        Optional[str],
        Field(
            description="The allocated size of the volume accessible to the associated workspace. This should include the scalar size as well as IEC standard unit in either decimal or binary form.",
            examples=["10GB", "2Ti", "1Pi"],
            title="Size allocated",
        ),
    ] = None
    persistent: Annotated[
        Optional[bool],
        Field(
            description="Indicates if the volume persists beyond the life of the resource it is associated with.",
            title="Persistent",
        ),
    ] = None
    remote: Annotated[
        Optional[bool],
        Field(
            description="Indicates if the volume is remotely (i.e., network) attached.",
            title="Remote",
        ),
    ] = None
    properties: Annotated[Optional[list[Property]], Field(title="Properties")] = None


class Type6(str, Enum):
    """
    The source type of event which caused the trigger to fire.
    """

    manual = "manual"
    api = "api"
    webhook = "webhook"
    scheduled = "scheduled"


class Type7(str, Enum):
    """
    Describes the type of data output.
    """

    artifact = "artifact"
    attestation = "attestation"
    log = "log"
    evidence = "evidence"
    metrics = "metrics"
    other = "other"


class Condition(BaseModel):
    """
    A condition that was used to determine a trigger should be activated.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    description: Annotated[
        Optional[str],
        Field(
            description="Describes the set of conditions which cause the trigger to activate.",
            title="Description",
        ),
    ] = None
    expression: Annotated[
        Optional[str],
        Field(
            description="The logical expression that was evaluated that determined the trigger should be fired.",
            title="Expression",
        ),
    ] = None
    properties: Annotated[Optional[list[Property]], Field(title="Properties")] = None


class TaskType(str, Enum):
    copy = "copy"
    clone = "clone"
    lint = "lint"
    scan = "scan"
    merge = "merge"
    build = "build"
    test = "test"
    deliver = "deliver"
    deploy = "deploy"
    release = "release"
    clean = "clean"
    other = "other"


class Parameter(BaseModel):
    """
    A representation of a functional parameter.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[
        Optional[str], Field(description="The name of the parameter.", title="Name")
    ] = None
    value: Annotated[
        Optional[str], Field(description="The value of the parameter.", title="Value")
    ] = None
    dataType: Annotated[
        Optional[str], Field(description="The data type of the parameter.", title="Data type")
    ] = None


class Algorithm(str, Enum):
    """
    Signature algorithm. The currently recognized JWA [RFC7518] and RFC8037 [RFC8037] asymmetric key algorithms. Note: Unlike RFC8037 [RFC8037] JSF requires explicit Ed* algorithm names instead of "EdDSA".
    """

    RS256 = "RS256"
    RS384 = "RS384"
    RS512 = "RS512"
    PS256 = "PS256"
    PS384 = "PS384"
    PS512 = "PS512"
    ES256 = "ES256"
    ES384 = "ES384"
    ES512 = "ES512"
    Ed25519 = "Ed25519"
    Ed448 = "Ed448"
    HS256 = "HS256"
    HS384 = "HS384"
    HS512 = "HS512"


class KeyType(str, Enum):
    """
    Key type indicator.
    """

    EC = "EC"
    OKP = "OKP"
    RSA = "RSA"


class PublicKey(BaseModel):
    """
    Optional. Public key object.
    """

    model_config = ConfigDict(
        extra="allow",
    )
    kty: KeyType


class OrganizationalEntity(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        Optional[RefType],
        Field(
            alias="bom-ref",
            description="An optional identifier which can be used to reference the object elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.",
            title="BOM Reference",
        ),
    ] = None
    name: Annotated[
        Optional[str],
        Field(description="The name of the organization", examples=["Example Inc."], title="Name"),
    ] = None
    url: Annotated[
        Optional[list[str]],
        Field(
            description="The URL of the organization. Multiple URLs are allowed.",
            examples=["https://example.com"],
            title="URL",
        ),
    ] = None
    contact: Annotated[
        Optional[list[OrganizationalContact]],
        Field(
            description="A contact at the organization. Multiple contacts are allowed.",
            title="Contact",
        ),
    ] = None


class Swid(BaseModel):
    """
    Specifies metadata and content for ISO-IEC 19770-2 Software Identification (SWID) Tags.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    tagId: Annotated[
        str, Field(description="Maps to the tagId of a SoftwareIdentity.", title="Tag ID")
    ]
    name: Annotated[str, Field(description="Maps to the name of a SoftwareIdentity.", title="Name")]
    version: Annotated[
        Optional[str],
        Field(description="Maps to the version of a SoftwareIdentity.", title="Version"),
    ] = "0.0"
    tagVersion: Annotated[
        Optional[int],
        Field(description="Maps to the tagVersion of a SoftwareIdentity.", title="Tag Version"),
    ] = 0
    patch: Annotated[
        Optional[bool], Field(description="Maps to the patch of a SoftwareIdentity.", title="Patch")
    ] = False
    text: Annotated[
        Optional[Attachment],
        Field(
            description="Specifies the metadata and content of the SWID tag.",
            title="Attachment text",
        ),
    ] = None
    url: Annotated[Optional[str], Field(description="The URL to the SWID file.", title="URL")] = (
        None
    )


class Hash(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    alg: HashAlg
    content: HashContent


class Licensor(BaseModel):
    """
    The individual or organization that grants a license to another individual or organization
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        OrganizationalEntity,
        Field(
            description="The organization that granted the license", title="Licensor (Organization)"
        ),
    ]
    individual: Annotated[
        Optional[OrganizationalContact],
        Field(
            description="The individual, not associated with an organization, that granted the license",
            title="Licensor (Individual)",
        ),
    ] = None


class Licensor1(BaseModel):
    """
    The individual or organization that grants a license to another individual or organization
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        Optional[OrganizationalEntity],
        Field(
            description="The organization that granted the license", title="Licensor (Organization)"
        ),
    ] = None
    individual: Annotated[
        OrganizationalContact,
        Field(
            description="The individual, not associated with an organization, that granted the license",
            title="Licensor (Individual)",
        ),
    ]


class Licensee(BaseModel):
    """
    The individual or organization for which a license was granted to
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        OrganizationalEntity,
        Field(
            description="The organization that was granted the license",
            title="Licensee (Organization)",
        ),
    ]
    individual: Annotated[
        Optional[OrganizationalContact],
        Field(
            description="The individual, not associated with an organization, that was granted the license",
            title="Licensee (Individual)",
        ),
    ] = None


class Licensee1(BaseModel):
    """
    The individual or organization for which a license was granted to
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        Optional[OrganizationalEntity],
        Field(
            description="The organization that was granted the license",
            title="Licensee (Organization)",
        ),
    ] = None
    individual: Annotated[
        OrganizationalContact,
        Field(
            description="The individual, not associated with an organization, that was granted the license",
            title="Licensee (Individual)",
        ),
    ]


class Purchaser(BaseModel):
    """
    The individual or organization that purchased the license
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        OrganizationalEntity,
        Field(
            description="The organization that purchased the license",
            title="Purchaser (Organization)",
        ),
    ]
    individual: Annotated[
        Optional[OrganizationalContact],
        Field(
            description="The individual, not associated with an organization, that purchased the license",
            title="Purchaser (Individual)",
        ),
    ] = None


class Purchaser1(BaseModel):
    """
    The individual or organization that purchased the license
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        Optional[OrganizationalEntity],
        Field(
            description="The organization that purchased the license",
            title="Purchaser (Organization)",
        ),
    ] = None
    individual: Annotated[
        OrganizationalContact,
        Field(
            description="The individual, not associated with an organization, that purchased the license",
            title="Purchaser (Individual)",
        ),
    ]


class Licensing(BaseModel):
    """
    Licensing details describing the licensor/licensee, license type, renewal and expiration dates, and other important metadata
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    altIds: Annotated[
        Optional[list[str]],
        Field(
            description="License identifiers that may be used to manage licenses and their lifecycle",
            title="Alternate License Identifiers",
        ),
    ] = None
    licensor: Annotated[
        Optional[Union[Licensor, Licensor1]],
        Field(
            description="The individual or organization that grants a license to another individual or organization",
            title="Licensor",
        ),
    ] = None
    licensee: Annotated[
        Optional[Union[Licensee, Licensee1]],
        Field(
            description="The individual or organization for which a license was granted to",
            title="Licensee",
        ),
    ] = None
    purchaser: Annotated[
        Optional[Union[Purchaser, Purchaser1]],
        Field(
            description="The individual or organization that purchased the license",
            title="Purchaser",
        ),
    ] = None
    purchaseOrder: Annotated[
        Optional[str],
        Field(
            description="The purchase order identifier the purchaser sent to a supplier or vendor to authorize a purchase",
            title="Purchase Order",
        ),
    ] = None
    licenseTypes: Annotated[
        Optional[list[LicenseType]],
        Field(
            description="The type of license(s) that was granted to the licensee\n\n* __academic__ = A license that grants use of software solely for the purpose of education or research.\n* __appliance__ = A license covering use of software embedded in a specific piece of hardware.\n* __client-access__ = A Client Access License (CAL) allows client computers to access services provided by server software.\n* __concurrent-user__ = A Concurrent User license (aka floating license) limits the number of licenses for a software application and licenses are shared among a larger number of users.\n* __core-points__ = A license where the core of a computer's processor is assigned a specific number of points.\n* __custom-metric__ = A license for which consumption is measured by non-standard metrics.\n* __device__ = A license that covers a defined number of installations on computers and other types of devices.\n* __evaluation__ = A license that grants permission to install and use software for trial purposes.\n* __named-user__ = A license that grants access to the software to one or more pre-defined users.\n* __node-locked__ = A license that grants access to the software on one or more pre-defined computers or devices.\n* __oem__ = An Original Equipment Manufacturer license that is delivered with hardware, cannot be transferred to other hardware, and is valid for the life of the hardware.\n* __perpetual__ = A license where the software is sold on a one-time basis and the licensee can use a copy of the software indefinitely.\n* __processor-points__ = A license where each installation consumes points per processor.\n* __subscription__ = A license where the licensee pays a fee to use the software or service.\n* __user__ = A license that grants access to the software or service by a specified number of users.\n* __other__ = Another license type.\n",
            title="License Type",
        ),
    ] = None
    lastRenewal: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The timestamp indicating when the license was last renewed. For new purchases, this is often the purchase or acquisition date. For non-perpetual licenses or subscriptions, this is the timestamp of when the license was last renewed.",
            title="Last Renewal",
        ),
    ] = None
    expiration: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The timestamp indicating when the current license expires (if applicable).",
            title="Expiration",
        ),
    ] = None


class License1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        Optional[RefType],
        Field(
            alias="bom-ref",
            description="An optional identifier which can be used to reference the license elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.",
            title="BOM Reference",
        ),
    ] = None
    id: Annotated[
        spdx.Schema,
        Field(
            description="A valid SPDX license ID",
            examples=["Apache-2.0"],
            title="License ID (SPDX)",
        ),
    ]
    name: Annotated[
        Optional[str],
        Field(
            description="If SPDX does not define the license used, this field may be used to provide the license name",
            examples=["Acme Software License"],
            title="License Name",
        ),
    ] = None
    text: Annotated[
        Optional[Attachment],
        Field(
            description="An optional way to include the textual content of a license.",
            title="License text",
        ),
    ] = None
    url: Annotated[
        Optional[str],
        Field(
            description="The URL to the license file. If specified, a 'license' externalReference should also be specified for completeness",
            examples=["https://www.apache.org/licenses/LICENSE-2.0.txt"],
            title="License URL",
        ),
    ] = None
    licensing: Annotated[
        Optional[Licensing],
        Field(
            description="Licensing details describing the licensor/licensee, license type, renewal and expiration dates, and other important metadata",
            title="Licensing information",
        ),
    ] = None
    properties: Annotated[
        Optional[list[Property]],
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is OPTIONAL.",
            title="Properties",
        ),
    ] = None


class Licensor2(BaseModel):
    """
    The individual or organization that grants a license to another individual or organization
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        OrganizationalEntity,
        Field(
            description="The organization that granted the license", title="Licensor (Organization)"
        ),
    ]
    individual: Annotated[
        Optional[OrganizationalContact],
        Field(
            description="The individual, not associated with an organization, that granted the license",
            title="Licensor (Individual)",
        ),
    ] = None


class Licensor3(BaseModel):
    """
    The individual or organization that grants a license to another individual or organization
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        Optional[OrganizationalEntity],
        Field(
            description="The organization that granted the license", title="Licensor (Organization)"
        ),
    ] = None
    individual: Annotated[
        OrganizationalContact,
        Field(
            description="The individual, not associated with an organization, that granted the license",
            title="Licensor (Individual)",
        ),
    ]


class Licensee2(BaseModel):
    """
    The individual or organization for which a license was granted to
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        OrganizationalEntity,
        Field(
            description="The organization that was granted the license",
            title="Licensee (Organization)",
        ),
    ]
    individual: Annotated[
        Optional[OrganizationalContact],
        Field(
            description="The individual, not associated with an organization, that was granted the license",
            title="Licensee (Individual)",
        ),
    ] = None


class Licensee3(BaseModel):
    """
    The individual or organization for which a license was granted to
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        Optional[OrganizationalEntity],
        Field(
            description="The organization that was granted the license",
            title="Licensee (Organization)",
        ),
    ] = None
    individual: Annotated[
        OrganizationalContact,
        Field(
            description="The individual, not associated with an organization, that was granted the license",
            title="Licensee (Individual)",
        ),
    ]


class Purchaser2(BaseModel):
    """
    The individual or organization that purchased the license
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        OrganizationalEntity,
        Field(
            description="The organization that purchased the license",
            title="Purchaser (Organization)",
        ),
    ]
    individual: Annotated[
        Optional[OrganizationalContact],
        Field(
            description="The individual, not associated with an organization, that purchased the license",
            title="Purchaser (Individual)",
        ),
    ] = None


class Purchaser3(BaseModel):
    """
    The individual or organization that purchased the license
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        Optional[OrganizationalEntity],
        Field(
            description="The organization that purchased the license",
            title="Purchaser (Organization)",
        ),
    ] = None
    individual: Annotated[
        OrganizationalContact,
        Field(
            description="The individual, not associated with an organization, that purchased the license",
            title="Purchaser (Individual)",
        ),
    ]


class Licensing1(BaseModel):
    """
    Licensing details describing the licensor/licensee, license type, renewal and expiration dates, and other important metadata
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    altIds: Annotated[
        Optional[list[str]],
        Field(
            description="License identifiers that may be used to manage licenses and their lifecycle",
            title="Alternate License Identifiers",
        ),
    ] = None
    licensor: Annotated[
        Optional[Union[Licensor2, Licensor3]],
        Field(
            description="The individual or organization that grants a license to another individual or organization",
            title="Licensor",
        ),
    ] = None
    licensee: Annotated[
        Optional[Union[Licensee2, Licensee3]],
        Field(
            description="The individual or organization for which a license was granted to",
            title="Licensee",
        ),
    ] = None
    purchaser: Annotated[
        Optional[Union[Purchaser2, Purchaser3]],
        Field(
            description="The individual or organization that purchased the license",
            title="Purchaser",
        ),
    ] = None
    purchaseOrder: Annotated[
        Optional[str],
        Field(
            description="The purchase order identifier the purchaser sent to a supplier or vendor to authorize a purchase",
            title="Purchase Order",
        ),
    ] = None
    licenseTypes: Annotated[
        Optional[list[LicenseType]],
        Field(
            description="The type of license(s) that was granted to the licensee\n\n* __academic__ = A license that grants use of software solely for the purpose of education or research.\n* __appliance__ = A license covering use of software embedded in a specific piece of hardware.\n* __client-access__ = A Client Access License (CAL) allows client computers to access services provided by server software.\n* __concurrent-user__ = A Concurrent User license (aka floating license) limits the number of licenses for a software application and licenses are shared among a larger number of users.\n* __core-points__ = A license where the core of a computer's processor is assigned a specific number of points.\n* __custom-metric__ = A license for which consumption is measured by non-standard metrics.\n* __device__ = A license that covers a defined number of installations on computers and other types of devices.\n* __evaluation__ = A license that grants permission to install and use software for trial purposes.\n* __named-user__ = A license that grants access to the software to one or more pre-defined users.\n* __node-locked__ = A license that grants access to the software on one or more pre-defined computers or devices.\n* __oem__ = An Original Equipment Manufacturer license that is delivered with hardware, cannot be transferred to other hardware, and is valid for the life of the hardware.\n* __perpetual__ = A license where the software is sold on a one-time basis and the licensee can use a copy of the software indefinitely.\n* __processor-points__ = A license where each installation consumes points per processor.\n* __subscription__ = A license where the licensee pays a fee to use the software or service.\n* __user__ = A license that grants access to the software or service by a specified number of users.\n* __other__ = Another license type.\n",
            title="License Type",
        ),
    ] = None
    lastRenewal: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The timestamp indicating when the license was last renewed. For new purchases, this is often the purchase or acquisition date. For non-perpetual licenses or subscriptions, this is the timestamp of when the license was last renewed.",
            title="Last Renewal",
        ),
    ] = None
    expiration: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The timestamp indicating when the current license expires (if applicable).",
            title="Expiration",
        ),
    ] = None


class License2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        Optional[RefType],
        Field(
            alias="bom-ref",
            description="An optional identifier which can be used to reference the license elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.",
            title="BOM Reference",
        ),
    ] = None
    id: Annotated[
        Optional[spdx.Schema],
        Field(
            description="A valid SPDX license ID",
            examples=["Apache-2.0"],
            title="License ID (SPDX)",
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description="If SPDX does not define the license used, this field may be used to provide the license name",
            examples=["Acme Software License"],
            title="License Name",
        ),
    ]
    text: Annotated[
        Optional[Attachment],
        Field(
            description="An optional way to include the textual content of a license.",
            title="License text",
        ),
    ] = None
    url: Annotated[
        Optional[str],
        Field(
            description="The URL to the license file. If specified, a 'license' externalReference should also be specified for completeness",
            examples=["https://www.apache.org/licenses/LICENSE-2.0.txt"],
            title="License URL",
        ),
    ] = None
    licensing: Annotated[
        Optional[Licensing1],
        Field(
            description="Licensing details describing the licensor/licensee, license type, renewal and expiration dates, and other important metadata",
            title="Licensing information",
        ),
    ] = None
    properties: Annotated[
        Optional[list[Property]],
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is OPTIONAL.",
            title="Properties",
        ),
    ] = None


class License(RootModel[Union[License1, License2]]):
    root: Annotated[Union[License1, License2], Field(title="License Object")]


class Commit(BaseModel):
    """
    Specifies an individual commit
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    uid: Annotated[
        Optional[str],
        Field(
            description="A unique identifier of the commit. This may be version control specific. For example, Subversion uses revision numbers whereas git uses commit hashes.",
            title="UID",
        ),
    ] = None
    url: Annotated[
        Optional[str],
        Field(
            description="The URL to the commit. This URL will typically point to a commit in a version control system.",
            title="URL",
        ),
    ] = None
    author: Annotated[
        Optional[IdentifiableAction],
        Field(description="The author who created the changes in the commit", title="Author"),
    ] = None
    committer: Annotated[
        Optional[IdentifiableAction],
        Field(description="The person who committed or pushed the commit", title="Committer"),
    ] = None
    message: Annotated[
        Optional[str],
        Field(description="The text description of the contents of the commit", title="Message"),
    ] = None


class Patch(BaseModel):
    """
    Specifies an individual patch
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    type: Annotated[
        Type1,
        Field(
            description="Specifies the purpose for the patch including the resolution of defects, security issues, or new behavior or functionality.\n\n* __unofficial__ = A patch which is not developed by the creators or maintainers of the software being patched. Refer to [https://en.wikipedia.org/wiki/Unofficial_patch](https://en.wikipedia.org/wiki/Unofficial_patch)\n* __monkey__ = A patch which dynamically modifies runtime behavior. Refer to [https://en.wikipedia.org/wiki/Monkey_patch](https://en.wikipedia.org/wiki/Monkey_patch)\n* __backport__ = A patch which takes code from a newer version of software and applies it to older versions of the same software. Refer to [https://en.wikipedia.org/wiki/Backporting](https://en.wikipedia.org/wiki/Backporting)\n* __cherry-pick__ = A patch created by selectively applying commits from other versions or branches of the same software.",
            title="Type",
        ),
    ]
    diff: Annotated[
        Optional[Diff],
        Field(
            description="The patch file (or diff) that show changes. Refer to [https://en.wikipedia.org/wiki/Diff](https://en.wikipedia.org/wiki/Diff)",
            title="Diff",
        ),
    ] = None
    resolves: Annotated[
        Optional[list[Issue]],
        Field(description="A collection of issues the patch resolves", title="Resolves"),
    ] = None


class ExternalReference(BaseModel):
    """
    External references provide a way to document systems, sites, and information that may be relevant, but are not included with the BOM. They may also establish specific relationships within or external to the BOM.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    url: Annotated[
        Union[str, BomLink],
        Field(
            description="The URI (URL or URN) to the external reference. External references are URIs and therefore can accept any URL scheme including https ([RFC-7230](https://www.ietf.org/rfc/rfc7230.txt)), mailto ([RFC-2368](https://www.ietf.org/rfc/rfc2368.txt)), tel ([RFC-3966](https://www.ietf.org/rfc/rfc3966.txt)), and dns ([RFC-4501](https://www.ietf.org/rfc/rfc4501.txt)). External references may also include formally registered URNs such as [CycloneDX BOM-Link](https://cyclonedx.org/capabilities/bomlink/) to reference CycloneDX BOMs or any object within a BOM. BOM-Link transforms applicable external references into relationships that can be expressed in a BOM or across BOMs.",
            title="URL",
        ),
    ]
    comment: Annotated[
        Optional[str],
        Field(description="An optional comment describing the external reference", title="Comment"),
    ] = None
    type: Annotated[
        Type3,
        Field(
            description='Specifies the type of external reference.\n\n* __vcs__ = Version Control System\n* __issue-tracker__ = Issue or defect tracking system, or an Application Lifecycle Management (ALM) system\n* __website__ = Website\n* __advisories__ = Security advisories\n* __bom__ = Bill of Materials (SBOM, OBOM, HBOM, SaaSBOM, etc)\n* __mailing-list__ = Mailing list or discussion group\n* __social__ = Social media account\n* __chat__ = Real-time chat platform\n* __documentation__ = Documentation, guides, or how-to instructions\n* __support__ = Community or commercial support\n* __distribution__ = Direct or repository download location\n* __distribution-intake__ = The location where a component was published to. This is often the same as "distribution" but may also include specialized publishing processes that act as an intermediary\n* __license__ = The URL to the license file. If a license URL has been defined in the license node, it should also be defined as an external reference for completeness\n* __build-meta__ = Build-system specific meta file (i.e. pom.xml, package.json, .nuspec, etc)\n* __build-system__ = URL to an automated build system\n* __release-notes__ = URL to release notes\n* __security-contact__ = Specifies a way to contact the maintainer, supplier, or provider in the event of a security incident. Common URIs include links to a disclosure procedure, a mailto (RFC-2368) that specifies an email address, a tel (RFC-3966) that specifies a phone number, or dns (RFC-4501) that specifies the records containing DNS Security TXT\n* __model-card__ = A model card describes the intended uses of a machine learning model, potential limitations, biases, ethical considerations, training parameters, datasets used to train the model, performance metrics, and other relevant data useful for ML transparency\n* __log__ = A record of events that occurred in a computer system or application, such as problems, errors, or information on current operations\n* __configuration__ = Parameters or settings that may be used by other components or services\n* __evidence__ = Information used to substantiate a claim\n* __formulation__ = Describes how a component or service was manufactured or deployed\n* __attestation__ = Human or machine-readable statements containing facts, evidence, or testimony\n* __threat-model__ = An enumeration of identified weaknesses, threats, and countermeasures, dataflow diagram (DFD), attack tree, and other supporting documentation in human-readable or machine-readable format\n* __adversary-model__ = The defined assumptions, goals, and capabilities of an adversary.\n* __risk-assessment__ = Identifies and analyzes the potential of future events that may negatively impact individuals, assets, and/or the environment. Risk assessments may also include judgments on the tolerability of each risk.\n* __vulnerability-assertion__ = A Vulnerability Disclosure Report (VDR) which asserts the known and previously unknown vulnerabilities that affect a component, service, or product including the analysis and findings describing the impact (or lack of impact) that the reported vulnerability has on a component, service, or product.\n* __exploitability-statement__ = A Vulnerability Exploitability eXchange (VEX) which asserts the known vulnerabilities that do not affect a product, product family, or organization, and optionally the ones that do. The VEX should include the analysis and findings describing the impact (or lack of impact) that the reported vulnerability has on the product, product family, or organization.\n* __pentest-report__ = Results from an authorized simulated cyberattack on a component or service, otherwise known as a penetration test\n* __static-analysis-report__ = SARIF or proprietary machine or human-readable report for which static analysis has identified code quality, security, and other potential issues with the source code\n* __dynamic-analysis-report__ = Dynamic analysis report that has identified issues such as vulnerabilities and misconfigurations\n* __runtime-analysis-report__ = Report generated by analyzing the call stack of a running application\n* __component-analysis-report__ = Report generated by Software Composition Analysis (SCA), container analysis, or other forms of component analysis\n* __maturity-report__ = Report containing a formal assessment of an organization, business unit, or team against a maturity model\n* __certification-report__ = Industry, regulatory, or other certification from an accredited (if applicable) certification body\n* __quality-metrics__ = Report or system in which quality metrics can be obtained\n* __codified-infrastructure__ = Code or configuration that defines and provisions virtualized infrastructure, commonly referred to as Infrastructure as Code (IaC)\n* __poam__ = Plans of Action and Milestones (POAM) compliment an "attestation" external reference. POAM is defined by NIST as a "document that identifies tasks needing to be accomplished. It details resources required to accomplish the elements of the plan, any milestones in meeting the tasks and scheduled completion dates for the milestones".\n* __other__ = Use this if no other types accurately describe the purpose of the external reference',
            title="Type",
        ),
    ]
    hashes: Annotated[
        Optional[list[Hash]],
        Field(description="The hashes of the external reference (if applicable).", title="Hashes"),
    ] = None


class Rating(BaseModel):
    """
    Defines the severity or risk ratings of a vulnerability.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    source: Annotated[
        Optional[VulnerabilitySource],
        Field(
            description="The source that calculated the severity or risk rating of the vulnerability."
        ),
    ] = None
    score: Annotated[
        Optional[float], Field(description="The numerical score of the rating.", title="Score")
    ] = None
    severity: Annotated[
        Optional[Severity],
        Field(
            description="Textual representation of the severity that corresponds to the numerical score of the rating."
        ),
    ] = None
    method: Optional[ScoreMethod] = None
    vector: Annotated[
        Optional[str],
        Field(
            description="Textual representation of the metric values used to score the vulnerability",
            title="Vector",
        ),
    ] = None
    justification: Annotated[
        Optional[str],
        Field(
            description="An optional reason for rating the vulnerability as it was",
            title="Justification",
        ),
    ] = None


class Credits(BaseModel):
    """
    Individuals or organizations credited with the discovery of the vulnerability.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    organizations: Annotated[
        Optional[list[OrganizationalEntity]],
        Field(
            description="The organizations credited with vulnerability discovery.",
            title="Organizations",
        ),
    ] = None
    individuals: Annotated[
        Optional[list[OrganizationalContact]],
        Field(
            description="The individuals, not associated with organizations, that are credited with vulnerability discovery.",
            title="Individuals",
        ),
    ] = None


class Versions(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    version: Annotated[Version, Field(description="A single version of a component or service.")]
    range: Annotated[
        Optional[Range],
        Field(
            description="A version range specified in Package URL Version Range syntax (vers) which is defined at https://github.com/package-url/purl-spec/VERSION-RANGE-SPEC.rst"
        ),
    ] = None
    status: Annotated[
        Optional[AffectedStatus],
        Field(description="The vulnerability status for the version or range of versions."),
    ] = "affected"


class Versions1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    version: Annotated[
        Optional[Version], Field(description="A single version of a component or service.")
    ] = None
    range: Annotated[
        Range,
        Field(
            description="A version range specified in Package URL Version Range syntax (vers) which is defined at https://github.com/package-url/purl-spec/VERSION-RANGE-SPEC.rst"
        ),
    ]
    status: Annotated[
        Optional[AffectedStatus],
        Field(description="The vulnerability status for the version or range of versions."),
    ] = "affected"


class Affect(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    ref: Annotated[
        Union[RefLinkType, BomLinkElementType],
        Field(
            description="References a component or service by the objects bom-ref",
            title="Reference",
        ),
    ]
    versions: Annotated[
        Optional[list[Union[Versions, Versions1]]],
        Field(
            description="Zero or more individual versions or range of versions.", title="Versions"
        ),
    ] = None


class Considerations(BaseModel):
    """
    What considerations should be taken into account regarding the model's construction, training, and application?
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    users: Annotated[
        Optional[list[str]],
        Field(description="Who are the intended users of the model?", title="Users"),
    ] = None
    useCases: Annotated[
        Optional[list[str]],
        Field(description="What are the intended use cases of the model?", title="Use Cases"),
    ] = None
    technicalLimitations: Annotated[
        Optional[list[str]],
        Field(
            description="What are the known technical limitations of the model? E.g. What kind(s) of data should the model be expected not to perform well on? What are the factors that might degrade model performance?",
            title="Technical Limitations",
        ),
    ] = None
    performanceTradeoffs: Annotated[
        Optional[list[str]],
        Field(
            description="What are the known tradeoffs in accuracy/performance of the model?",
            title="Performance Tradeoffs",
        ),
    ] = None
    ethicalConsiderations: Annotated[
        Optional[list[Risk]],
        Field(
            description="What are the ethical (or environmental) risks involved in the application of this model?",
            title="Ethical Considerations",
        ),
    ] = None
    fairnessAssessments: Annotated[
        Optional[list[FairnessAssessment]],
        Field(
            description="How does the model affect groups at risk of being systematically disadvantaged? What are the harms and benefits to the various affected groups?",
            title="Fairness Assessments",
        ),
    ] = None


class DataGovernanceResponsibleParty1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[OrganizationalEntity, Field(title="Organization")]
    contact: Annotated[Optional[OrganizationalContact], Field(title="Individual")] = None


class DataGovernanceResponsibleParty2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[Optional[OrganizationalEntity], Field(title="Organization")] = None
    contact: Annotated[OrganizationalContact, Field(title="Individual")]


class DataGovernanceResponsibleParty(
    RootModel[Union[DataGovernanceResponsibleParty1, DataGovernanceResponsibleParty2]]
):
    root: Union[DataGovernanceResponsibleParty1, DataGovernanceResponsibleParty2]


class GraphicsCollection(BaseModel):
    """
    A collection of graphics that represent various measurements.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    description: Annotated[
        Optional[str], Field(description="A description of this collection of graphics.")
    ] = None
    collection: Annotated[
        Optional[list[Graphic]], Field(description="A collection of graphics.")
    ] = None


class Step(BaseModel):
    """
    Executes specific commands or tools in order to accomplish its owning task as part of a sequence.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[Optional[str], Field(description="A name for the step.", title="Name")] = None
    description: Annotated[
        Optional[str], Field(description="A description of the step.", title="Description")
    ] = None
    commands: Annotated[
        Optional[list[Command]],
        Field(description="Ordered list of commands or directives for the step", title="Commands"),
    ] = None
    properties: Annotated[Optional[list[Property]], Field(title="Properties")] = None


class ResourceReferenceChoice1(BaseModel):
    """
    A reference to a locally defined resource (e.g., a bom-ref) or an externally accessible resource.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    ref: Annotated[
        Union[RefLinkType, BomLinkElementType],
        Field(description="References an object by its bom-ref attribute", title="BOM Reference"),
    ]
    externalReference: Annotated[
        Optional[ExternalReference],
        Field(
            description="Reference to an externally accessible resource.",
            title="External reference",
        ),
    ] = None


class ResourceReferenceChoice2(BaseModel):
    """
    A reference to a locally defined resource (e.g., a bom-ref) or an externally accessible resource.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    ref: Annotated[
        Optional[Union[RefLinkType, BomLinkElementType]],
        Field(description="References an object by its bom-ref attribute", title="BOM Reference"),
    ] = None
    externalReference: Annotated[
        ExternalReference,
        Field(
            description="Reference to an externally accessible resource.",
            title="External reference",
        ),
    ]


class ResourceReferenceChoice(RootModel[Union[ResourceReferenceChoice1, ResourceReferenceChoice2]]):
    root: Annotated[
        Union[ResourceReferenceChoice1, ResourceReferenceChoice2],
        Field(
            description="A reference to a locally defined resource (e.g., a bom-ref) or an externally accessible resource.",
            title="Resource reference choice",
        ),
    ]


class Signer(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    algorithm: Union[Algorithm, AnyUrl]
    keyId: Annotated[
        Optional[str],
        Field(
            description="Optional. Application specific string identifying the signature key.",
            title="Key ID",
        ),
    ] = None
    publicKey: Annotated[
        Optional[PublicKey], Field(description="Optional. Public key object.", title="Public key")
    ] = None
    certificatePath: Annotated[
        Optional[list[str]],
        Field(
            description="Optional. Sorted array of X.509 [RFC5280] certificates, where the first element must contain the signature certificate. The certificate path must be contiguous but is not required to be complete.",
            title="Certificate path",
        ),
    ] = None
    excludes: Annotated[
        Optional[list[str]],
        Field(
            description='Optional. Array holding the names of one or more application level properties that must be excluded from the signature process. Note that the "excludes" property itself, must also be excluded from the signature process. Since both the "excludes" property and the associated data it points to are unsigned, a conforming JSF implementation must provide options for specifying which properties to accept.',
            title="Excludes",
        ),
    ] = None
    value: Annotated[
        str,
        Field(
            description="The signature data. Note that the binary representation must follow the JWA [RFC7518] specifications.",
            title="Signature",
        ),
    ]


class Tool(BaseModel):
    """
    [Deprecated] - DO NOT USE. This will be removed in a future version. This will be removed in a future version. Use component or service instead. Information about the automated or manual tool used
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    vendor: Annotated[
        Optional[str],
        Field(description="The name of the vendor who created the tool", title="Tool Vendor"),
    ] = None
    name: Annotated[Optional[str], Field(description="The name of the tool", title="Tool Name")] = (
        None
    )
    version: Annotated[
        Optional[str], Field(description="The version of the tool", title="Tool Version")
    ] = None
    hashes: Annotated[
        Optional[list[Hash]],
        Field(description="The hashes of the tool (if applicable).", title="Hashes"),
    ] = None
    externalReferences: Annotated[
        Optional[list[ExternalReference]],
        Field(
            description="External references provide a way to document systems, sites, and information that may be relevant, but are not included with the BOM. They may also establish specific relationships within or external to the BOM.",
            title="External References",
        ),
    ] = None


class QuantitativeAnalysis(BaseModel):
    """
    A quantitative analysis of the model
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    performanceMetrics: Annotated[
        Optional[list[PerformanceMetric]],
        Field(
            description="The model performance metrics being reported. Examples may include accuracy, F1 score, precision, top-3 error rates, MSC, etc.",
            title="Performance Metrics",
        ),
    ] = None
    graphics: Optional[GraphicsCollection] = None


class DataGovernance(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    custodians: Annotated[
        Optional[list[DataGovernanceResponsibleParty]],
        Field(
            description="Data custodians are responsible for the safe custody, transport, and storage of data.",
            title="Data Custodians",
        ),
    ] = None
    stewards: Annotated[
        Optional[list[DataGovernanceResponsibleParty]],
        Field(
            description="Data stewards are responsible for data content, context, and associated business rules.",
            title="Data Stewards",
        ),
    ] = None
    owners: Annotated[
        Optional[list[DataGovernanceResponsibleParty]],
        Field(
            description="Data owners are concerned with risk and appropriate access to data.",
            title="Data Owners",
        ),
    ] = None


class Workspace(BaseModel):
    """
    A named filesystem or data resource shareable by workflow tasks.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType,
        Field(
            alias="bom-ref",
            description="An optional identifier which can be used to reference the workspace elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.",
            title="BOM Reference",
        ),
    ]
    uid: Annotated[
        str,
        Field(
            description="The unique identifier for the resource instance within its deployment context.",
            title="Unique Identifier (UID)",
        ),
    ]
    name: Annotated[
        Optional[str], Field(description="The name of the resource instance.", title="Name")
    ] = None
    aliases: Annotated[
        Optional[list[str]],
        Field(
            description="The names for the workspace as referenced by other workflow tasks. Effectively, a name mapping so other tasks can use their own local name in their steps.",
            title="Aliases",
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(description="A description of the resource instance.", title="Description"),
    ] = None
    resourceReferences: Annotated[
        Optional[list[ResourceReferenceChoice]],
        Field(
            description="References to component or service resources that are used to realize the resource instance.",
            title="Resource references",
        ),
    ] = None
    accessMode: Annotated[
        Optional[AccessMode],
        Field(
            description="Describes the read-write access control for the workspace relative to the owning resource instance.",
            title="Access mode",
        ),
    ] = None
    mountPath: Annotated[
        Optional[str],
        Field(
            description="A path to a location on disk where the workspace will be available to the associated task's steps.",
            title="Mount path",
        ),
    ] = None
    managedDataType: Annotated[
        Optional[str],
        Field(
            description="The name of a domain-specific data type the workspace represents.",
            examples=["ConfigMap", "Secret"],
            title="Managed data type",
        ),
    ] = None
    volumeRequest: Annotated[
        Optional[str],
        Field(
            description="Identifies the reference to the request for a specific volume type and parameters.",
            examples=["a kubernetes Persistent Volume Claim (PVC) name"],
            title="Volume request",
        ),
    ] = None
    volume: Annotated[
        Optional[Volume],
        Field(
            description="Information about the actual volume instance allocated to the workspace.",
            examples=["see https://kubernetes.io/docs/concepts/storage/persistent-volumes/"],
            title="Volume",
        ),
    ] = None
    properties: Annotated[Optional[list[Property]], Field(title="Properties")] = None


class Event(BaseModel):
    """
    Represents something that happened that may trigger a response.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    uid: Annotated[
        Optional[str],
        Field(description="The unique identifier of the event.", title="Unique Identifier (UID)"),
    ] = None
    description: Annotated[
        Optional[str], Field(description="A description of the event.", title="Description")
    ] = None
    timeReceived: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The date and time (timestamp) when the event was received.",
            title="Time Received",
        ),
    ] = None
    data: Annotated[
        Optional[Attachment], Field(description="Encoding of the raw event data.", title="Data")
    ] = None
    source: Annotated[
        Optional[ResourceReferenceChoice],
        Field(
            description="References the component or service that was the source of the event",
            title="Source",
        ),
    ] = None
    target: Annotated[
        Optional[ResourceReferenceChoice],
        Field(
            description="References the component or service that was the target of the event",
            title="Target",
        ),
    ] = None
    properties: Annotated[Optional[list[Property]], Field(title="Properties")] = None


class InputType1(BaseModel):
    """
    Type that represents various input data types and formats.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    source: Annotated[
        Optional[ResourceReferenceChoice],
        Field(
            description="A references to the component or service that provided the input to the task (e.g., reference to a service with data flow value of `inbound`)",
            examples=["source code repository", "database"],
            title="Source",
        ),
    ] = None
    target: Annotated[
        Optional[ResourceReferenceChoice],
        Field(
            description="A reference to the component or service that received or stored the input if not the task itself (e.g., a local, named storage workspace)",
            examples=["workspace", "directory"],
            title="Target",
        ),
    ] = None
    resource: Annotated[
        ResourceReferenceChoice,
        Field(
            description="A reference to an independent resource provided as an input to a task by the workflow runtime.",
            examples=[
                "reference to a configuration file in a repository (i.e., a bom-ref)",
                "reference to a scanning service used in a task (i.e., a bom-ref)",
            ],
            title="Resource",
        ),
    ]
    parameters: Annotated[
        Optional[list[Parameter]],
        Field(
            description="Inputs that have the form of parameters with names and values.",
            title="Parameters",
        ),
    ] = None
    environmentVars: Annotated[
        Optional[list[Union[Property, str]]],
        Field(
            description="Inputs that have the form of parameters with names and values.",
            title="Environment variables",
        ),
    ] = None
    data: Annotated[
        Optional[Attachment], Field(description="Inputs that have the form of data.", title="Data")
    ] = None
    properties: Annotated[Optional[list[Property]], Field(title="Properties")] = None


class InputType2(BaseModel):
    """
    Type that represents various input data types and formats.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    source: Annotated[
        Optional[ResourceReferenceChoice],
        Field(
            description="A references to the component or service that provided the input to the task (e.g., reference to a service with data flow value of `inbound`)",
            examples=["source code repository", "database"],
            title="Source",
        ),
    ] = None
    target: Annotated[
        Optional[ResourceReferenceChoice],
        Field(
            description="A reference to the component or service that received or stored the input if not the task itself (e.g., a local, named storage workspace)",
            examples=["workspace", "directory"],
            title="Target",
        ),
    ] = None
    resource: Annotated[
        Optional[ResourceReferenceChoice],
        Field(
            description="A reference to an independent resource provided as an input to a task by the workflow runtime.",
            examples=[
                "reference to a configuration file in a repository (i.e., a bom-ref)",
                "reference to a scanning service used in a task (i.e., a bom-ref)",
            ],
            title="Resource",
        ),
    ] = None
    parameters: Annotated[
        list[Parameter],
        Field(
            description="Inputs that have the form of parameters with names and values.",
            title="Parameters",
        ),
    ]
    environmentVars: Annotated[
        Optional[list[Union[Property, str]]],
        Field(
            description="Inputs that have the form of parameters with names and values.",
            title="Environment variables",
        ),
    ] = None
    data: Annotated[
        Optional[Attachment], Field(description="Inputs that have the form of data.", title="Data")
    ] = None
    properties: Annotated[Optional[list[Property]], Field(title="Properties")] = None


class InputType3(BaseModel):
    """
    Type that represents various input data types and formats.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    source: Annotated[
        Optional[ResourceReferenceChoice],
        Field(
            description="A references to the component or service that provided the input to the task (e.g., reference to a service with data flow value of `inbound`)",
            examples=["source code repository", "database"],
            title="Source",
        ),
    ] = None
    target: Annotated[
        Optional[ResourceReferenceChoice],
        Field(
            description="A reference to the component or service that received or stored the input if not the task itself (e.g., a local, named storage workspace)",
            examples=["workspace", "directory"],
            title="Target",
        ),
    ] = None
    resource: Annotated[
        Optional[ResourceReferenceChoice],
        Field(
            description="A reference to an independent resource provided as an input to a task by the workflow runtime.",
            examples=[
                "reference to a configuration file in a repository (i.e., a bom-ref)",
                "reference to a scanning service used in a task (i.e., a bom-ref)",
            ],
            title="Resource",
        ),
    ] = None
    parameters: Annotated[
        Optional[list[Parameter]],
        Field(
            description="Inputs that have the form of parameters with names and values.",
            title="Parameters",
        ),
    ] = None
    environmentVars: Annotated[
        list[Union[Property, str]],
        Field(
            description="Inputs that have the form of parameters with names and values.",
            title="Environment variables",
        ),
    ]
    data: Annotated[
        Optional[Attachment], Field(description="Inputs that have the form of data.", title="Data")
    ] = None
    properties: Annotated[Optional[list[Property]], Field(title="Properties")] = None


class InputType4(BaseModel):
    """
    Type that represents various input data types and formats.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    source: Annotated[
        Optional[ResourceReferenceChoice],
        Field(
            description="A references to the component or service that provided the input to the task (e.g., reference to a service with data flow value of `inbound`)",
            examples=["source code repository", "database"],
            title="Source",
        ),
    ] = None
    target: Annotated[
        Optional[ResourceReferenceChoice],
        Field(
            description="A reference to the component or service that received or stored the input if not the task itself (e.g., a local, named storage workspace)",
            examples=["workspace", "directory"],
            title="Target",
        ),
    ] = None
    resource: Annotated[
        Optional[ResourceReferenceChoice],
        Field(
            description="A reference to an independent resource provided as an input to a task by the workflow runtime.",
            examples=[
                "reference to a configuration file in a repository (i.e., a bom-ref)",
                "reference to a scanning service used in a task (i.e., a bom-ref)",
            ],
            title="Resource",
        ),
    ] = None
    parameters: Annotated[
        Optional[list[Parameter]],
        Field(
            description="Inputs that have the form of parameters with names and values.",
            title="Parameters",
        ),
    ] = None
    environmentVars: Annotated[
        Optional[list[Union[Property, str]]],
        Field(
            description="Inputs that have the form of parameters with names and values.",
            title="Environment variables",
        ),
    ] = None
    data: Annotated[
        Attachment, Field(description="Inputs that have the form of data.", title="Data")
    ]
    properties: Annotated[Optional[list[Property]], Field(title="Properties")] = None


class InputType(RootModel[Union[InputType1, InputType2, InputType3, InputType4]]):
    root: Annotated[
        Union[InputType1, InputType2, InputType3, InputType4],
        Field(
            description="Type that represents various input data types and formats.",
            title="Input type",
        ),
    ]


class OutputType1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Annotated[
        Optional[Type7], Field(description="Describes the type of data output.", title="Type")
    ] = None
    source: Annotated[
        Optional[ResourceReferenceChoice],
        Field(
            description="Component or service that generated or provided the output from the task (e.g., a build tool)",
            title="Source",
        ),
    ] = None
    target: Annotated[
        Optional[ResourceReferenceChoice],
        Field(
            description="Component or service that received the output from the task (e.g., reference to an artifactory service with data flow value of `outbound`)",
            examples=["a log file described as an `externalReference` within its target domain."],
            title="Target",
        ),
    ] = None
    resource: Annotated[
        ResourceReferenceChoice,
        Field(
            description="A reference to an independent resource generated as output by the task.",
            examples=["configuration file", "source code", "scanning service"],
            title="Resource",
        ),
    ]
    data: Annotated[
        Optional[Attachment], Field(description="Outputs that have the form of data.", title="Data")
    ] = None
    environmentVars: Annotated[
        Optional[list[Union[Property, str]]],
        Field(
            description="Outputs that have the form of environment variables.",
            title="Environment variables",
        ),
    ] = None
    properties: Annotated[Optional[list[Property]], Field(title="Properties")] = None


class OutputType2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Annotated[
        Optional[Type7], Field(description="Describes the type of data output.", title="Type")
    ] = None
    source: Annotated[
        Optional[ResourceReferenceChoice],
        Field(
            description="Component or service that generated or provided the output from the task (e.g., a build tool)",
            title="Source",
        ),
    ] = None
    target: Annotated[
        Optional[ResourceReferenceChoice],
        Field(
            description="Component or service that received the output from the task (e.g., reference to an artifactory service with data flow value of `outbound`)",
            examples=["a log file described as an `externalReference` within its target domain."],
            title="Target",
        ),
    ] = None
    resource: Annotated[
        Optional[ResourceReferenceChoice],
        Field(
            description="A reference to an independent resource generated as output by the task.",
            examples=["configuration file", "source code", "scanning service"],
            title="Resource",
        ),
    ] = None
    data: Annotated[
        Optional[Attachment], Field(description="Outputs that have the form of data.", title="Data")
    ] = None
    environmentVars: Annotated[
        list[Union[Property, str]],
        Field(
            description="Outputs that have the form of environment variables.",
            title="Environment variables",
        ),
    ]
    properties: Annotated[Optional[list[Property]], Field(title="Properties")] = None


class OutputType3(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Annotated[
        Optional[Type7], Field(description="Describes the type of data output.", title="Type")
    ] = None
    source: Annotated[
        Optional[ResourceReferenceChoice],
        Field(
            description="Component or service that generated or provided the output from the task (e.g., a build tool)",
            title="Source",
        ),
    ] = None
    target: Annotated[
        Optional[ResourceReferenceChoice],
        Field(
            description="Component or service that received the output from the task (e.g., reference to an artifactory service with data flow value of `outbound`)",
            examples=["a log file described as an `externalReference` within its target domain."],
            title="Target",
        ),
    ] = None
    resource: Annotated[
        Optional[ResourceReferenceChoice],
        Field(
            description="A reference to an independent resource generated as output by the task.",
            examples=["configuration file", "source code", "scanning service"],
            title="Resource",
        ),
    ] = None
    data: Annotated[
        Attachment, Field(description="Outputs that have the form of data.", title="Data")
    ]
    environmentVars: Annotated[
        Optional[list[Union[Property, str]]],
        Field(
            description="Outputs that have the form of environment variables.",
            title="Environment variables",
        ),
    ] = None
    properties: Annotated[Optional[list[Property]], Field(title="Properties")] = None


class OutputType(RootModel[Union[OutputType1, OutputType2, OutputType3]]):
    root: Union[OutputType1, OutputType2, OutputType3]


class Signature1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    signers: Annotated[
        Optional[list[Signer]],
        Field(
            description="Unique top level property for Multiple Signatures. (multisignature)",
            title="Signature",
        ),
    ] = None


class Signature2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    chain: Annotated[
        Optional[list[Signer]],
        Field(
            description="Unique top level property for Signature Chains. (signaturechain)",
            title="Signature",
        ),
    ] = None


class Signature(RootModel[Union[Signature1, Signature2, Signer]]):
    root: Annotated[Union[Signature1, Signature2, Signer], Field(title="Signature")]


class ServiceData(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    flow: Annotated[
        DataFlowDirection,
        Field(
            description="Specifies the flow direction of the data. Direction is relative to the service. Inbound flow states that data enters the service. Outbound flow states that data leaves the service. Bi-directional states that data flows both ways, and unknown states that the direction is not known.",
            title="Directional Flow",
        ),
    ]
    classification: DataClassification
    name: Annotated[
        Optional[str],
        Field(
            description="Name for the defined data",
            examples=["Credit card reporting"],
            title="Name",
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description="Short description of the data content and usage",
            examples=[
                "Credit card information being exchanged in between the web app and the database"
            ],
            title="Description",
        ),
    ] = None
    governance: Annotated[Optional[DataGovernance], Field(title="Data Governance")] = None
    source: Annotated[
        Optional[list[Union[str, BomLinkElementType]]],
        Field(
            description="The URI, URL, or BOM-Link of the components or services the data came in from",
            title="Source",
        ),
    ] = None
    destination: Annotated[
        Optional[list[Union[str, BomLinkElementType]]],
        Field(
            description="The URI, URL, or BOM-Link of the components or services the data is sent to",
            title="Destination",
        ),
    ] = None


class ComponentData(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        Optional[RefType],
        Field(
            alias="bom-ref",
            description="An optional identifier which can be used to reference the dataset elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.",
            title="BOM Reference",
        ),
    ] = None
    type: Annotated[
        Type5,
        Field(
            description="The general theme or subject matter of the data being specified.\n\n* __source-code__ = Any type of code, code snippet, or data-as-code.\n* __configuration__ = Parameters or settings that may be used by other components.\n* __dataset__ = A collection of data.\n* __definition__ = Data that can be used to create new instances of what the definition defines.\n* __other__ = Any other type of data that does not fit into existing definitions.",
            title="Type of Data",
        ),
    ]
    name: Annotated[Optional[str], Field(description="The name of the dataset.")] = None
    contents: Annotated[
        Optional[Contents],
        Field(
            description="The contents or references to the contents of the data being described.",
            title="Data Contents",
        ),
    ] = None
    classification: Optional[DataClassification] = None
    sensitiveData: Annotated[
        Optional[list[str]], Field(description="A description of any sensitive data in a dataset.")
    ] = None
    graphics: Optional[GraphicsCollection] = None
    description: Annotated[
        Optional[str],
        Field(
            description="A description of the dataset. Can describe size of dataset, whether it's used for source code, training, testing, or validation, etc."
        ),
    ] = None
    governance: Annotated[Optional[DataGovernance], Field(title="Data Governance")] = None


class Trigger(BaseModel):
    """
    Represents a resource that can conditionally activate (or fire) tasks based upon associated events and their data.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType,
        Field(
            alias="bom-ref",
            description="An optional identifier which can be used to reference the trigger elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.",
            title="BOM Reference",
        ),
    ]
    uid: Annotated[
        str,
        Field(
            description="The unique identifier for the resource instance within its deployment context.",
            title="Unique Identifier (UID)",
        ),
    ]
    name: Annotated[
        Optional[str], Field(description="The name of the resource instance.", title="Name")
    ] = None
    description: Annotated[
        Optional[str],
        Field(description="A description of the resource instance.", title="Description"),
    ] = None
    resourceReferences: Annotated[
        Optional[list[ResourceReferenceChoice]],
        Field(
            description="References to component or service resources that are used to realize the resource instance.",
            title="Resource references",
        ),
    ] = None
    type: Annotated[
        Type6,
        Field(
            description="The source type of event which caused the trigger to fire.", title="Type"
        ),
    ]
    event: Annotated[
        Optional[Event],
        Field(
            description="The event data that caused the associated trigger to activate.",
            title="Event",
        ),
    ] = None
    conditions: Optional[list[Condition]] = None
    timeActivated: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The date and time (timestamp) when the trigger was activated.",
            title="Time activated",
        ),
    ] = None
    inputs: Annotated[
        Optional[list[InputType]],
        Field(
            description="Represents resources and data brought into a task at runtime by executor or task commands",
            examples=[
                "a `configuration` file which was declared as a local `component` or `externalReference`"
            ],
            title="Inputs",
        ),
    ] = None
    outputs: Annotated[
        Optional[list[OutputType]],
        Field(
            description="Represents resources and data output from a task at runtime by executor or task commands",
            examples=["a log file or metrics data produced by the task"],
            title="Outputs",
        ),
    ] = None
    properties: Annotated[Optional[list[Property]], Field(title="Properties")] = None


class Service(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        Optional[RefType],
        Field(
            alias="bom-ref",
            description="An optional identifier which can be used to reference the service elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.",
            title="BOM Reference",
        ),
    ] = None
    provider: Annotated[
        Optional[OrganizationalEntity],
        Field(description="The organization that provides the service.", title="Provider"),
    ] = None
    group: Annotated[
        Optional[str],
        Field(
            description="The grouping name, namespace, or identifier. This will often be a shortened, single name of the company or project that produced the service or domain name. Whitespace and special characters should be avoided.",
            examples=["com.acme"],
            title="Service Group",
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description="The name of the service. This will often be a shortened, single name of the service.",
            examples=["ticker-service"],
            title="Service Name",
        ),
    ]
    version: Annotated[
        Optional[str],
        Field(description="The service version.", examples=["1.0.0"], title="Service Version"),
    ] = None
    description: Annotated[
        Optional[str],
        Field(description="Specifies a description for the service", title="Service Description"),
    ] = None
    endpoints: Annotated[
        Optional[list[str]],
        Field(
            description="The endpoint URIs of the service. Multiple endpoints are allowed.",
            examples=["https://example.com/api/v1/ticker"],
            title="Endpoints",
        ),
    ] = None
    authenticated: Annotated[
        Optional[bool],
        Field(
            description="A boolean value indicating if the service requires authentication. A value of true indicates the service requires authentication prior to use. A value of false indicates the service does not require authentication.",
            title="Authentication Required",
        ),
    ] = None
    x_trust_boundary: Annotated[
        Optional[bool],
        Field(
            alias="x-trust-boundary",
            description="A boolean value indicating if use of the service crosses a trust zone or boundary. A value of true indicates that by using the service, a trust boundary is crossed. A value of false indicates that by using the service, a trust boundary is not crossed.",
            title="Crosses Trust Boundary",
        ),
    ] = None
    trustZone: Annotated[
        Optional[str],
        Field(description="The name of the trust zone the service resides in.", title="Trust Zone"),
    ] = None
    data: Annotated[
        Optional[list[ServiceData]],
        Field(
            description="Specifies information about the data including the directional flow of data and the data classification.",
            title="Data",
        ),
    ] = None
    licenses: Annotated[Optional[LicenseChoice], Field(title="Component License(s)")] = None
    externalReferences: Annotated[
        Optional[list[ExternalReference]],
        Field(
            description="External references provide a way to document systems, sites, and information that may be relevant, but are not included with the BOM. They may also establish specific relationships within or external to the BOM.",
            title="External References",
        ),
    ] = None
    services: Annotated[
        Optional[list[Service]],
        Field(
            description="A list of services included or deployed behind the parent service. This is not a dependency tree. It provides a way to specify a hierarchical representation of service assemblies.",
            title="Services",
        ),
    ] = None
    releaseNotes: Annotated[
        Optional[ReleaseNotes],
        Field(description="Specifies optional release notes.", title="Release notes"),
    ] = None
    properties: Annotated[
        Optional[list[Property]],
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is OPTIONAL.",
            title="Properties",
        ),
    ] = None
    signature: Annotated[
        Optional[Signature],
        Field(
            description="Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).",
            title="Signature",
        ),
    ] = None


class Compositions(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        Optional[RefType],
        Field(
            alias="bom-ref",
            description="An optional identifier which can be used to reference the composition elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.",
            title="BOM Reference",
        ),
    ] = None
    aggregate: Annotated[
        AggregateType,
        Field(
            description="Specifies an aggregate type that describe how complete a relationship is.\n\n* __complete__ = The relationship is complete. No further relationships including constituent components, services, or dependencies are known to exist.\n* __incomplete__ = The relationship is incomplete. Additional relationships exist and may include constituent components, services, or dependencies.\n* __incomplete&#95;first&#95;party&#95;only__ = The relationship is incomplete. Only relationships for first-party components, services, or their dependencies are represented.\n* __incomplete&#95;first&#95;party&#95;proprietary&#95;only__ = The relationship is incomplete. Only relationships for first-party components, services, or their dependencies are represented, limited specifically to those that are proprietary.\n* __incomplete&#95;first&#95;party&#95;opensource&#95;only__ = The relationship is incomplete. Only relationships for first-party components, services, or their dependencies are represented, limited specifically to those that are opensource.\n* __incomplete&#95;third&#95;party&#95;only__ = The relationship is incomplete. Only relationships for third-party components, services, or their dependencies are represented.\n* __incomplete&#95;third&#95;party&#95;proprietary&#95;only__ = The relationship is incomplete. Only relationships for third-party components, services, or their dependencies are represented, limited specifically to those that are proprietary.\n* __incomplete&#95;third&#95;party&#95;opensource&#95;only__ = The relationship is incomplete. Only relationships for third-party components, services, or their dependencies are represented, limited specifically to those that are opensource.\n* __unknown__ = The relationship may be complete or incomplete. This usually signifies a 'best-effort' to obtain constituent components, services, or dependencies but the completeness is inconclusive.\n* __not&#95;specified__ = The relationship completeness is not specified.\n",
            title="Aggregate",
        ),
    ]
    assemblies: Annotated[
        Optional[list[Union[RefLinkType, BomLinkElementType]]],
        Field(
            description="The bom-ref identifiers of the components or services being described. Assemblies refer to nested relationships whereby a constituent part may include other constituent parts. References do not cascade to child parts. References are explicit for the specified constituent part only.",
            title="BOM references",
        ),
    ] = None
    dependencies: Annotated[
        Optional[list[str]],
        Field(
            description="The bom-ref identifiers of the components or services being described. Dependencies refer to a relationship whereby an independent constituent part requires another independent constituent part. References do not cascade to transitive dependencies. References are explicit for the specified dependency only.",
            title="BOM references",
        ),
    ] = None
    vulnerabilities: Annotated[
        Optional[list[str]],
        Field(
            description="The bom-ref identifiers of the vulnerabilities being described.",
            title="BOM references",
        ),
    ] = None
    signature: Annotated[
        Optional[Signature],
        Field(
            description="Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).",
            title="Signature",
        ),
    ] = None


class ModelParameters(BaseModel):
    """
    Hyper-parameters for construction of the model.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    approach: Annotated[
        Optional[Approach],
        Field(
            description="The overall approach to learning used by the model for problem solving.",
            title="Approach",
        ),
    ] = None
    task: Annotated[
        Optional[str],
        Field(
            description="Directly influences the input and/or output. Examples include classification, regression, clustering, etc.",
            title="Task",
        ),
    ] = None
    architectureFamily: Annotated[
        Optional[str],
        Field(
            description="The model architecture family such as transformer network, convolutional neural network, residual neural network, LSTM neural network, etc.",
            title="Architecture Family",
        ),
    ] = None
    modelArchitecture: Annotated[
        Optional[str],
        Field(
            description="The specific architecture of the model such as GPT-1, ResNet-50, YOLOv3, etc.",
            title="Model Architecture",
        ),
    ] = None
    datasets: Annotated[
        Optional[list[Union[ComponentData, Datasets]]],
        Field(description="The datasets used to train and evaluate the model.", title="Datasets"),
    ] = None
    inputs: Annotated[
        Optional[list[InputOutputMLParameters]],
        Field(description="The input format(s) of the model", title="Inputs"),
    ] = None
    outputs: Annotated[
        Optional[list[InputOutputMLParameters]],
        Field(description="The output format(s) from the model", title="Outputs"),
    ] = None


class ModelCard(BaseModel):
    """
    A model card describes the intended uses of a machine learning model and potential limitations, including biases and ethical considerations. Model cards typically contain the training parameters, which datasets were used to train the model, performance metrics, and other relevant data useful for ML transparency. This object SHOULD be specified for any component of type `machine-learning-model` and MUST NOT be specified for other component types.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        Optional[RefType],
        Field(
            alias="bom-ref",
            description="An optional identifier which can be used to reference the model card elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.",
            title="BOM Reference",
        ),
    ] = None
    modelParameters: Annotated[
        Optional[ModelParameters],
        Field(
            description="Hyper-parameters for construction of the model.", title="Model Parameters"
        ),
    ] = None
    quantitativeAnalysis: Annotated[
        Optional[QuantitativeAnalysis],
        Field(description="A quantitative analysis of the model", title="Quantitative Analysis"),
    ] = None
    considerations: Annotated[
        Optional[Considerations],
        Field(
            description="What considerations should be taken into account regarding the model's construction, training, and application?",
            title="Considerations",
        ),
    ] = None
    properties: Annotated[
        Optional[list[Property]],
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is OPTIONAL.",
            title="Properties",
        ),
    ] = None


class Task(BaseModel):
    """
    Describes the inputs, sequence of steps and resources used to accomplish a task and its output.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType,
        Field(
            alias="bom-ref",
            description="An optional identifier which can be used to reference the task elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.",
            title="BOM Reference",
        ),
    ]
    uid: Annotated[
        str,
        Field(
            description="The unique identifier for the resource instance within its deployment context.",
            title="Unique Identifier (UID)",
        ),
    ]
    name: Annotated[
        Optional[str], Field(description="The name of the resource instance.", title="Name")
    ] = None
    description: Annotated[
        Optional[str],
        Field(description="A description of the resource instance.", title="Description"),
    ] = None
    resourceReferences: Annotated[
        Optional[list[ResourceReferenceChoice]],
        Field(
            description="References to component or service resources that are used to realize the resource instance.",
            title="Resource references",
        ),
    ] = None
    taskTypes: Annotated[
        list[TaskType],
        Field(
            description="Indicates the types of activities performed by the set of workflow tasks.",
            title="Task types",
        ),
    ]
    trigger: Annotated[
        Optional[Trigger],
        Field(description="The trigger that initiated the task.", title="Trigger"),
    ] = None
    steps: Annotated[
        Optional[list[Step]],
        Field(description="The sequence of steps for the task.", title="Steps"),
    ] = None
    inputs: Annotated[
        Optional[list[InputType]],
        Field(
            description="Represents resources and data brought into a task at runtime by executor or task commands",
            examples=[
                "a `configuration` file which was declared as a local `component` or `externalReference`"
            ],
            title="Inputs",
        ),
    ] = None
    outputs: Annotated[
        Optional[list[OutputType]],
        Field(
            description="Represents resources and data output from a task at runtime by executor or task commands",
            examples=["a log file or metrics data produced by the task"],
            title="Outputs",
        ),
    ] = None
    timeStart: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The date and time (timestamp) when the task started.", title="Time start"
        ),
    ] = None
    timeEnd: Annotated[
        Optional[AwareDatetime],
        Field(description="The date and time (timestamp) when the task ended.", title="Time end"),
    ] = None
    workspaces: Annotated[
        Optional[list[Workspace]],
        Field(
            description="A set of named filesystem or data resource shareable by workflow tasks.",
            title="Workspaces",
        ),
    ] = None
    runtimeTopology: Annotated[
        Optional[list[Dependency]],
        Field(
            description="A graph of the component runtime topology for task's instance.",
            title="Runtime topology",
        ),
    ] = None
    properties: Annotated[Optional[list[Property]], Field(title="Properties")] = None


class Workflow(BaseModel):
    """
    A specialized orchestration task.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        RefType,
        Field(
            alias="bom-ref",
            description="An optional identifier which can be used to reference the workflow elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.",
            title="BOM Reference",
        ),
    ]
    uid: Annotated[
        str,
        Field(
            description="The unique identifier for the resource instance within its deployment context.",
            title="Unique Identifier (UID)",
        ),
    ]
    name: Annotated[
        Optional[str], Field(description="The name of the resource instance.", title="Name")
    ] = None
    description: Annotated[
        Optional[str],
        Field(description="A description of the resource instance.", title="Description"),
    ] = None
    resourceReferences: Annotated[
        Optional[list[ResourceReferenceChoice]],
        Field(
            description="References to component or service resources that are used to realize the resource instance.",
            title="Resource references",
        ),
    ] = None
    tasks: Annotated[
        Optional[list[Task]],
        Field(description="The tasks that comprise the workflow.", title="Tasks"),
    ] = None
    taskDependencies: Annotated[
        Optional[list[Dependency]],
        Field(
            description="The graph of dependencies between tasks within the workflow.",
            title="Task dependency graph",
        ),
    ] = None
    taskTypes: Annotated[
        list[TaskType],
        Field(
            description="Indicates the types of activities performed by the set of workflow tasks.",
            title="Task types",
        ),
    ]
    trigger: Annotated[
        Optional[Trigger],
        Field(description="The trigger that initiated the task.", title="Trigger"),
    ] = None
    steps: Annotated[
        Optional[list[Step]],
        Field(description="The sequence of steps for the task.", title="Steps"),
    ] = None
    inputs: Annotated[
        Optional[list[InputType]],
        Field(
            description="Represents resources and data brought into a task at runtime by executor or task commands",
            examples=[
                "a `configuration` file which was declared as a local `component` or `externalReference`"
            ],
            title="Inputs",
        ),
    ] = None
    outputs: Annotated[
        Optional[list[OutputType]],
        Field(
            description="Represents resources and data output from a task at runtime by executor or task commands",
            examples=["a log file or metrics data produced by the task"],
            title="Outputs",
        ),
    ] = None
    timeStart: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The date and time (timestamp) when the task started.", title="Time start"
        ),
    ] = None
    timeEnd: Annotated[
        Optional[AwareDatetime],
        Field(description="The date and time (timestamp) when the task ended.", title="Time end"),
    ] = None
    workspaces: Annotated[
        Optional[list[Workspace]],
        Field(
            description="A set of named filesystem or data resource shareable by workflow tasks.",
            title="Workspaces",
        ),
    ] = None
    runtimeTopology: Annotated[
        Optional[list[Dependency]],
        Field(
            description="A graph of the component runtime topology for workflow's instance.",
            title="Runtime topology",
        ),
    ] = None
    properties: Annotated[Optional[list[Property]], Field(title="Properties")] = None


class CyclonedxSoftwareBillOfMaterialsStandard(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    field_schema: Annotated[Optional[FieldSchema], Field(alias="$schema")] = None
    bomFormat: Annotated[
        BomFormat,
        Field(
            description='Specifies the format of the BOM. This helps to identify the file as CycloneDX since BOMs do not have a filename convention nor does JSON schema support namespaces. This value MUST be "CycloneDX".',
            title="BOM Format",
        ),
    ]
    specVersion: Annotated[
        str,
        Field(
            description="The version of the CycloneDX specification a BOM conforms to (starting at version 1.2).",
            examples=["1.5"],
            title="CycloneDX Specification Version",
        ),
    ]
    serialNumber: Annotated[
        Optional[str],
        Field(
            description="Every BOM generated SHOULD have a unique serial number, even if the contents of the BOM have not changed over time. If specified, the serial number MUST conform to RFC-4122. Use of serial numbers are RECOMMENDED.",
            examples=["urn:uuid:3e671687-395b-41f5-a30f-a58921a69b79"],
            pattern="^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$",
            title="BOM Serial Number",
        ),
    ] = None
    version: Annotated[
        Optional[int],
        Field(
            description="Whenever an existing BOM is modified, either manually or through automated processes, the version of the BOM SHOULD be incremented by 1. When a system is presented with multiple BOMs with identical serial numbers, the system SHOULD use the most recent version of the BOM. The default version is '1'.",
            examples=[1],
            ge=1,
            title="BOM Version",
        ),
    ] = 1
    metadata: Annotated[
        Optional[Metadata],
        Field(description="Provides additional information about a BOM.", title="BOM Metadata"),
    ] = None
    components: Annotated[
        Optional[list[Component]],
        Field(description="A list of software and hardware components.", title="Components"),
    ] = None
    services: Annotated[
        Optional[list[Service]],
        Field(
            description="A list of services. This may include microservices, function-as-a-service, and other types of network or intra-process services.",
            title="Services",
        ),
    ] = None
    externalReferences: Annotated[
        Optional[list[ExternalReference]],
        Field(
            description="External references provide a way to document systems, sites, and information that may be relevant, but are not included with the BOM. They may also establish specific relationships within or external to the BOM.",
            title="External References",
        ),
    ] = None
    dependencies: Annotated[
        Optional[list[Dependency]],
        Field(
            description="Provides the ability to document dependency relationships.",
            title="Dependencies",
        ),
    ] = None
    compositions: Annotated[
        Optional[list[Compositions]],
        Field(
            description="Compositions describe constituent parts (including components, services, and dependency relationships) and their completeness. The completeness of vulnerabilities expressed in a BOM may also be described.",
            title="Compositions",
        ),
    ] = None
    vulnerabilities: Annotated[
        Optional[list[Vulnerability]],
        Field(
            description="Vulnerabilities identified in components or services.",
            title="Vulnerabilities",
        ),
    ] = None
    annotations: Annotated[
        Optional[list[Annotations]],
        Field(
            description="Comments made by people, organizations, or tools about any object with a bom-ref, such as components, services, vulnerabilities, or the BOM itself. Unlike inventory information, annotations may contain opinion or commentary from various stakeholders. Annotations may be inline (with inventory) or externalized via BOM-Link, and may optionally be signed.",
            title="Annotations",
        ),
    ] = None
    formulation: Annotated[
        Optional[list[Formula]],
        Field(
            description="Describes how a component or service was manufactured or deployed. This is achieved through the use of formulas, workflows, tasks, and steps, which declare the precise steps to reproduce along with the observed formulas describing the steps which transpired in the manufacturing process.",
            title="Formulation",
        ),
    ] = None
    properties: Annotated[
        Optional[list[Property]],
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is OPTIONAL.",
            title="Properties",
        ),
    ] = None
    signature: Annotated[
        Optional[Signature],
        Field(
            description="Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).",
            title="Signature",
        ),
    ] = None


class Tools(BaseModel):
    """
    The tool(s) used in the creation of the BOM.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    components: Annotated[
        Optional[list[Component]],
        Field(
            description="A list of software and hardware components used as tools",
            title="Components",
        ),
    ] = None
    services: Annotated[
        Optional[list[Service]],
        Field(
            description="A list of services used as tools. This may include microservices, function-as-a-service, and other types of network or intra-process services.",
            title="Services",
        ),
    ] = None


class Metadata(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    timestamp: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The date and time (timestamp) when the BOM was created.", title="Timestamp"
        ),
    ] = None
    lifecycles: Annotated[
        Optional[list[Union[Lifecycles, Lifecycles1]]], Field(description="", title="Lifecycles")
    ] = None
    tools: Optional[Union[Tools, list[Tool]]] = None
    authors: Annotated[
        Optional[list[OrganizationalContact]],
        Field(
            description="The person(s) who created the BOM. Authors are common in BOMs created through manual processes. BOMs created through automated means may not have authors.",
            title="Authors",
        ),
    ] = None
    component: Annotated[
        Optional[Component],
        Field(description="The component that the BOM describes.", title="Component"),
    ] = None
    manufacture: Annotated[
        Optional[OrganizationalEntity],
        Field(
            description="The organization that manufactured the component that the BOM describes.",
            title="Manufacture",
        ),
    ] = None
    supplier: Annotated[
        Optional[OrganizationalEntity],
        Field(
            description=" The organization that supplied the component that the BOM describes. The supplier may often be the manufacturer, but may also be a distributor or repackager.",
            title="Supplier",
        ),
    ] = None
    licenses: Annotated[Optional[LicenseChoice], Field(title="BOM License(s)")] = None
    properties: Annotated[
        Optional[list[Property]],
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is OPTIONAL.",
            title="Properties",
        ),
    ] = None


class Pedigree(BaseModel):
    """
    Component pedigree is a way to document complex supply chain scenarios where components are created, distributed, modified, redistributed, combined with other components, etc. Pedigree supports viewing this complex chain from the beginning, the end, or anywhere in the middle. It also provides a way to document variants where the exact relation may not be known.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    ancestors: Annotated[
        Optional[list[Component]],
        Field(
            description="Describes zero or more components in which a component is derived from. This is commonly used to describe forks from existing projects where the forked version contains a ancestor node containing the original component it was forked from. For example, Component A is the original component. Component B is the component being used and documented in the BOM. However, Component B contains a pedigree node with a single ancestor documenting Component A - the original component from which Component B is derived from.",
            title="Ancestors",
        ),
    ] = None
    descendants: Annotated[
        Optional[list[Component]],
        Field(
            description="Descendants are the exact opposite of ancestors. This provides a way to document all forks (and their forks) of an original or root component.",
            title="Descendants",
        ),
    ] = None
    variants: Annotated[
        Optional[list[Component]],
        Field(
            description="Variants describe relations where the relationship between the components are not known. For example, if Component A contains nearly identical code to Component B. They are both related, but it is unclear if one is derived from the other, or if they share a common ancestor.",
            title="Variants",
        ),
    ] = None
    commits: Annotated[
        Optional[list[Commit]],
        Field(
            description="A list of zero or more commits which provide a trail describing how the component deviates from an ancestor, descendant, or variant.",
            title="Commits",
        ),
    ] = None
    patches: Annotated[
        Optional[list[Patch]],
        Field(
            description=">A list of zero or more patches describing how the component deviates from an ancestor, descendant, or variant. Patches may be complimentary to commits or may be used in place of commits.",
            title="Patches",
        ),
    ] = None
    notes: Annotated[
        Optional[str],
        Field(
            description="Notes, observations, and other non-structured commentary describing the components pedigree.",
            title="Notes",
        ),
    ] = None


class Component(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Annotated[
        Type,
        Field(
            description="Specifies the type of component. For software components, classify as application if no more specific appropriate classification is available or cannot be determined for the component. Types include:\n\n* __application__ = A software application. Refer to [https://en.wikipedia.org/wiki/Application_software](https://en.wikipedia.org/wiki/Application_software) for information about applications.\n* __framework__ = A software framework. Refer to [https://en.wikipedia.org/wiki/Software_framework](https://en.wikipedia.org/wiki/Software_framework) for information on how frameworks vary slightly from libraries.\n* __library__ = A software library. Refer to [https://en.wikipedia.org/wiki/Library_(computing)](https://en.wikipedia.org/wiki/Library_(computing))\n for information about libraries. All third-party and open source reusable components will likely be a library. If the library also has key features of a framework, then it should be classified as a framework. If not, or is unknown, then specifying library is RECOMMENDED.\n* __container__ = A packaging and/or runtime format, not specific to any particular technology, which isolates software inside the container from software outside of a container through virtualization technology. Refer to [https://en.wikipedia.org/wiki/OS-level_virtualization](https://en.wikipedia.org/wiki/OS-level_virtualization)\n* __platform__ = A runtime environment which interprets or executes software. This may include runtimes such as those that execute bytecode or low-code/no-code application platforms.\n* __operating-system__ = A software operating system without regard to deployment model (i.e. installed on physical hardware, virtual machine, image, etc) Refer to [https://en.wikipedia.org/wiki/Operating_system](https://en.wikipedia.org/wiki/Operating_system)\n* __device__ = A hardware device such as a processor, or chip-set. A hardware device containing firmware SHOULD include a component for the physical hardware itself, and another component of type 'firmware' or 'operating-system' (whichever is relevant), describing information about the software running on the device.\n  See also the list of [known device properties](https://github.com/CycloneDX/cyclonedx-property-taxonomy/blob/main/cdx/device.md).\n* __device-driver__ = A special type of software that operates or controls a particular type of device. Refer to [https://en.wikipedia.org/wiki/Device_driver](https://en.wikipedia.org/wiki/Device_driver)\n* __firmware__ = A special type of software that provides low-level control over a devices hardware. Refer to [https://en.wikipedia.org/wiki/Firmware](https://en.wikipedia.org/wiki/Firmware)\n* __file__ = A computer file. Refer to [https://en.wikipedia.org/wiki/Computer_file](https://en.wikipedia.org/wiki/Computer_file) for information about files.\n* __machine-learning-model__ = A model based on training data that can make predictions or decisions without being explicitly programmed to do so.\n* __data__ = A collection of discrete values that convey information.",
            examples=["library"],
            title="Component Type",
        ),
    ]
    mime_type: Annotated[
        Optional[str],
        Field(
            alias="mime-type",
            description="The optional mime-type of the component. When used on file components, the mime-type can provide additional context about the kind of file being represented such as an image, font, or executable. Some library or framework components may also have an associated mime-type.",
            examples=["image/jpeg"],
            pattern="^[-+a-z0-9.]+/[-+a-z0-9.]+$",
            title="Mime-Type",
        ),
    ] = None
    bom_ref: Annotated[
        Optional[RefType],
        Field(
            alias="bom-ref",
            description="An optional identifier which can be used to reference the component elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.",
            title="BOM Reference",
        ),
    ] = None
    supplier: Annotated[
        Optional[OrganizationalEntity],
        Field(
            description=" The organization that supplied the component. The supplier may often be the manufacturer, but may also be a distributor or repackager.",
            title="Component Supplier",
        ),
    ] = None
    author: Annotated[
        Optional[str],
        Field(
            description="The person(s) or organization(s) that authored the component",
            examples=["Acme Inc"],
            title="Component Author",
        ),
    ] = None
    publisher: Annotated[
        Optional[str],
        Field(
            description="The person(s) or organization(s) that published the component",
            examples=["Acme Inc"],
            title="Component Publisher",
        ),
    ] = None
    group: Annotated[
        Optional[str],
        Field(
            description="The grouping name or identifier. This will often be a shortened, single name of the company or project that produced the component, or the source package or domain name. Whitespace and special characters should be avoided. Examples include: apache, org.apache.commons, and apache.org.",
            examples=["com.acme"],
            title="Component Group",
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description="The name of the component. This will often be a shortened, single name of the component. Examples: commons-lang3 and jquery",
            examples=["tomcat-catalina"],
            title="Component Name",
        ),
    ]
    version: Annotated[
        Optional[str],
        Field(
            description="The component version. The version should ideally comply with semantic versioning but is not enforced.",
            examples=["9.0.14"],
            title="Component Version",
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description="Specifies a description for the component", title="Component Description"
        ),
    ] = None
    scope: Annotated[
        Optional[Scope],
        Field(
            description="Specifies the scope of the component. If scope is not specified, 'required' scope SHOULD be assumed by the consumer of the BOM.",
            title="Component Scope",
        ),
    ] = "required"
    hashes: Annotated[Optional[list[Hash]], Field(title="Component Hashes")] = None
    licenses: Annotated[Optional[LicenseChoice], Field(title="Component License(s)")] = None
    copyright: Annotated[
        Optional[str],
        Field(
            description="A copyright notice informing users of the underlying claims to copyright ownership in a published work.",
            examples=["Acme Inc"],
            title="Component Copyright",
        ),
    ] = None
    cpe: Annotated[
        Optional[str],
        Field(
            description="Specifies a well-formed CPE name that conforms to the CPE 2.2 or 2.3 specification. See [https://nvd.nist.gov/products/cpe](https://nvd.nist.gov/products/cpe)",
            examples=["cpe:2.3:a:acme:component_framework:-:*:*:*:*:*:*:*"],
            title="Component Common Platform Enumeration (CPE)",
        ),
    ] = None
    purl: Annotated[
        Optional[str],
        Field(
            description="Specifies the package-url (purl). The purl, if specified, MUST be valid and conform to the specification defined at: [https://github.com/package-url/purl-spec](https://github.com/package-url/purl-spec)",
            examples=["pkg:maven/com.acme/tomcat-catalina@9.0.14?packaging=jar"],
            title="Component Package URL (purl)",
        ),
    ] = None
    swid: Annotated[
        Optional[Swid],
        Field(
            description="Specifies metadata and content for [ISO-IEC 19770-2 Software Identification (SWID) Tags](https://www.iso.org/standard/65666.html).",
            title="SWID Tag",
        ),
    ] = None
    modified: Annotated[
        Optional[bool],
        Field(
            description="[Deprecated] - DO NOT USE. This will be removed in a future version. Use the pedigree element instead to supply information on exactly how the component was modified. A boolean value indicating if the component has been modified from the original. A value of true indicates the component is a derivative of the original. A value of false indicates the component has not been modified from the original.",
            title="Component Modified From Original",
        ),
    ] = None
    pedigree: Annotated[
        Optional[Pedigree],
        Field(
            description="Component pedigree is a way to document complex supply chain scenarios where components are created, distributed, modified, redistributed, combined with other components, etc. Pedigree supports viewing this complex chain from the beginning, the end, or anywhere in the middle. It also provides a way to document variants where the exact relation may not be known.",
            title="Component Pedigree",
        ),
    ] = None
    externalReferences: Annotated[
        Optional[list[ExternalReference]],
        Field(
            description="External references provide a way to document systems, sites, and information that may be relevant, but are not included with the BOM. They may also establish specific relationships within or external to the BOM.",
            title="External References",
        ),
    ] = None
    components: Annotated[
        Optional[list[Component]],
        Field(
            description="A list of software and hardware components included in the parent component. This is not a dependency tree. It provides a way to specify a hierarchical representation of component assemblies, similar to system &#8594; subsystem &#8594; parts assembly in physical supply chains.",
            title="Components",
        ),
    ] = None
    evidence: Annotated[
        Optional[ComponentEvidence],
        Field(
            description="Provides the ability to document evidence collected through various forms of extraction or analysis.",
            title="Evidence",
        ),
    ] = None
    releaseNotes: Annotated[
        Optional[ReleaseNotes],
        Field(description="Specifies optional release notes.", title="Release notes"),
    ] = None
    modelCard: Annotated[Optional[ModelCard], Field(title="Machine Learning Model Card")] = None
    data: Annotated[
        Optional[list[ComponentData]],
        Field(
            description="This object SHOULD be specified for any component of type `data` and MUST NOT be specified for other component types.",
            title="Data",
        ),
    ] = None
    properties: Annotated[
        Optional[list[Property]],
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is OPTIONAL.",
            title="Properties",
        ),
    ] = None
    signature: Annotated[
        Optional[Signature],
        Field(
            description="Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).",
            title="Signature",
        ),
    ] = None


class Tools1(BaseModel):
    """
    The tool(s) used to identify, confirm, or score the vulnerability.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    components: Annotated[
        Optional[list[Component]],
        Field(
            description="A list of software and hardware components used as tools",
            title="Components",
        ),
    ] = None
    services: Annotated[
        Optional[list[Service]],
        Field(
            description="A list of services used as tools. This may include microservices, function-as-a-service, and other types of network or intra-process services.",
            title="Services",
        ),
    ] = None


class Vulnerability(BaseModel):
    """
    Defines a weakness in a component or service that could be exploited or triggered by a threat source.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        Optional[RefType],
        Field(
            alias="bom-ref",
            description="An optional identifier which can be used to reference the vulnerability elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.",
            title="BOM Reference",
        ),
    ] = None
    id: Annotated[
        Optional[str],
        Field(
            description="The identifier that uniquely identifies the vulnerability.",
            examples=["CVE-2021-39182", "GHSA-35m5-8cvj-8783", "SNYK-PYTHON-ENROCRYPT-1912876"],
            title="ID",
        ),
    ] = None
    source: Annotated[
        Optional[VulnerabilitySource],
        Field(description="The source that published the vulnerability.")
    ] = None
    references: Annotated[
        Optional[list[Reference]],
        Field(
            description="Zero or more pointers to vulnerabilities that are the equivalent of the vulnerability specified. Often times, the same vulnerability may exist in multiple sources of vulnerability intelligence, but have different identifiers. References provide a way to correlate vulnerabilities across multiple sources of vulnerability intelligence.",
            title="References",
        ),
    ] = None
    ratings: Annotated[
        Optional[list[Rating]], Field(description="List of vulnerability ratings", title="Ratings")
    ] = None
    cwes: Annotated[
        Optional[list[Cwe]],
        Field(
            description="List of Common Weaknesses Enumerations (CWEs) codes that describes this vulnerability. For example 399 (of https://cwe.mitre.org/data/definitions/399.html)",
            examples=[399],
            title="CWEs",
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description="A description of the vulnerability as provided by the source.",
            title="Description",
        ),
    ] = None
    detail: Annotated[
        Optional[str],
        Field(
            description="If available, an in-depth description of the vulnerability as provided by the source organization. Details often include information useful in understanding root cause.",
            title="Details",
        ),
    ] = None
    recommendation: Annotated[
        Optional[str],
        Field(
            description="Recommendations of how the vulnerability can be remediated or mitigated.",
            title="Recommendation",
        ),
    ] = None
    workaround: Annotated[
        Optional[str],
        Field(
            description="A bypass, usually temporary, of the vulnerability that reduces its likelihood and/or impact. Workarounds often involve changes to configuration or deployments.",
            title="Workarounds",
        ),
    ] = None
    proofOfConcept: Annotated[
        Optional[ProofOfConcept],
        Field(
            description="Evidence used to reproduce the vulnerability.", title="Proof of Concept"
        ),
    ] = None
    advisories: Annotated[
        Optional[list[Advisory]],
        Field(
            description="Published advisories of the vulnerability if provided.", title="Advisories"
        ),
    ] = None
    created: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The date and time (timestamp) when the vulnerability record was created in the vulnerability database.",
            title="Created",
        ),
    ] = None
    published: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The date and time (timestamp) when the vulnerability record was first published.",
            title="Published",
        ),
    ] = None
    updated: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The date and time (timestamp) when the vulnerability record was last updated.",
            title="Updated",
        ),
    ] = None
    rejected: Annotated[
        Optional[AwareDatetime],
        Field(
            description="The date and time (timestamp) when the vulnerability record was rejected (if applicable).",
            title="Rejected",
        ),
    ] = None
    credits: Annotated[
        Optional[Credits],
        Field(
            description="Individuals or organizations credited with the discovery of the vulnerability.",
            title="Credits",
        ),
    ] = None
    tools: Optional[Union[Tools1, list[Tool]]] = None
    analysis: Annotated[
        Optional[Analysis],
        Field(
            description="An assessment of the impact and exploitability of the vulnerability.",
            title="Impact Analysis",
        ),
    ] = None
    affects: Annotated[
        Optional[list[Affect]],
        Field(
            description="The components or services that are affected by the vulnerability.",
            title="Affects",
        ),
    ] = None
    properties: Annotated[
        Optional[list[Property]],
        Field(
            description="Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is OPTIONAL.",
            title="Properties",
        ),
    ] = None


class Annotator(BaseModel):
    """
    The organization, person, component, or service which created the textual content of the annotation.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        OrganizationalEntity, Field(description="The organization that created the annotation")
    ]
    individual: Annotated[
        Optional[OrganizationalContact], Field(description="The person that created the annotation")
    ] = None
    component: Annotated[
        Optional[Component], Field(description="The tool or component that created the annotation")
    ] = None
    service: Annotated[
        Optional[Service], Field(description="The service that created the annotation")
    ] = None


class Annotator1(BaseModel):
    """
    The organization, person, component, or service which created the textual content of the annotation.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        Optional[OrganizationalEntity],
        Field(description="The organization that created the annotation"),
    ] = None
    individual: Annotated[
        OrganizationalContact, Field(description="The person that created the annotation")
    ]
    component: Annotated[
        Optional[Component], Field(description="The tool or component that created the annotation")
    ] = None
    service: Annotated[
        Optional[Service], Field(description="The service that created the annotation")
    ] = None


class Annotator2(BaseModel):
    """
    The organization, person, component, or service which created the textual content of the annotation.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        Optional[OrganizationalEntity],
        Field(description="The organization that created the annotation"),
    ] = None
    individual: Annotated[
        Optional[OrganizationalContact], Field(description="The person that created the annotation")
    ] = None
    component: Annotated[
        Component, Field(description="The tool or component that created the annotation")
    ]
    service: Annotated[
        Optional[Service], Field(description="The service that created the annotation")
    ] = None


class Annotator3(BaseModel):
    """
    The organization, person, component, or service which created the textual content of the annotation.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    organization: Annotated[
        Optional[OrganizationalEntity],
        Field(description="The organization that created the annotation"),
    ] = None
    individual: Annotated[
        Optional[OrganizationalContact], Field(description="The person that created the annotation")
    ] = None
    component: Annotated[
        Optional[Component], Field(description="The tool or component that created the annotation")
    ] = None
    service: Annotated[Service, Field(description="The service that created the annotation")]


class Annotations(BaseModel):
    """
    A comment, note, explanation, or similar textual content which provides additional context to the object(s) being annotated.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        Optional[RefType],
        Field(
            alias="bom-ref",
            description="An optional identifier which can be used to reference the annotation elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.",
            title="BOM Reference",
        ),
    ] = None
    subjects: Annotated[
        list[Union[RefLinkType, BomLinkElementType]],
        Field(
            description="The object in the BOM identified by its bom-ref. This is often a component or service, but may be any object type supporting bom-refs.",
            title="BOM References",
        ),
    ]
    annotator: Annotated[
        Union[Annotator, Annotator1, Annotator2, Annotator3],
        Field(
            description="The organization, person, component, or service which created the textual content of the annotation.",
            title="Annotator",
        ),
    ]
    timestamp: Annotated[
        AwareDatetime,
        Field(
            description="The date and time (timestamp) when the annotation was created.",
            title="Timestamp",
        ),
    ]
    text: Annotated[str, Field(description="The textual content of the annotation.", title="Text")]
    signature: Annotated[
        Optional[Signature],
        Field(
            description="Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).",
            title="Signature",
        ),
    ] = None


class Formula(BaseModel):
    """
    Describes workflows and resources that captures rules and other aspects of how the associated BOM component or service was formed.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    bom_ref: Annotated[
        Optional[RefType],
        Field(
            alias="bom-ref",
            description="An optional identifier which can be used to reference the formula elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.",
            title="BOM Reference",
        ),
    ] = None
    components: Annotated[
        Optional[list[Component]],
        Field(
            description="Transient components that are used in tasks that constitute one or more of this formula's workflows",
            title="Components",
        ),
    ] = None
    services: Annotated[
        Optional[list[Service]],
        Field(
            description="Transient services that are used in tasks that constitute one or more of this formula's workflows",
            title="Services",
        ),
    ] = None
    workflows: Annotated[
        Optional[list[Workflow]],
        Field(
            description="List of workflows that can be declared to accomplish specific orchestrated goals and independently triggered.",
            title="Workflows",
        ),
    ] = None
    properties: Annotated[Optional[list[Property]], Field(title="Properties")] = None


Service.model_rebuild()
CyclonedxSoftwareBillOfMaterialsStandard.model_rebuild()
Tools.model_rebuild()
Metadata.model_rebuild()
Pedigree.model_rebuild()
