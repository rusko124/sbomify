"""API endpoints for vulnerability scanning settings and management."""

import logging
from typing import Any, Dict, List, Optional

from django.db import models
from django.http import HttpRequest
from django.shortcuts import get_object_or_404
from ninja import Router
from ninja.params import Query
from ninja.security import django_auth
from pydantic import BaseModel, Field

from access_tokens.auth import PersonalAccessTokenAuth
from core.utils import token_to_number
from teams.models import Member, Team

from .models import (
    ComponentDependencyTrackMapping,
    DependencyTrackServer,
    TeamVulnerabilitySettings,
    VulnerabilityScanResult,
)
from .services import VulnerabilityScanningService

logger = logging.getLogger(__name__)

router = Router(tags=["Vulnerability Scanning"], auth=(PersonalAccessTokenAuth(), django_auth))


def _validate_team_access(
    request: HttpRequest, team_key: str, allowed_roles: list[str]
) -> tuple[bool, str, Team | None]:
    """
    Validate team access supporting both session-based (web UI) and token-based (API) authentication.

    Returns:
        (is_valid, error_message, team): Tuple of validation result
    """
    if not request.user.is_authenticated:
        return False, "Not logged in", None

    # Get the team object first
    try:
        team_id = token_to_number(team_key)
        team = Team.objects.get(pk=team_id)
    except (ValueError, Team.DoesNotExist):
        return False, "Team not found", None

    # Check if user is a member of this team
    member = Member.objects.filter(user=request.user, team=team).first()
    if not member:
        return False, "Access denied", None

    # Check role permissions
    if member.role not in allowed_roles:
        return False, "You don't have sufficient permissions to access this page", None

    # For web UI requests, also validate session team context
    current_team = request.session.get("current_team", {})
    current_team_key = current_team.get("key")

    # If session has team context, enforce it matches the requested team
    if current_team_key is not None and current_team_key != team_key:
        return False, "Access denied - please switch to this team first", None

    return True, "", team


# Schemas
class VulnerabilityProviderChoice(BaseModel):
    """Available vulnerability provider choices."""

    value: str
    label: str
    description: str
    available: bool = True
    plan_required: Optional[str] = None


class DependencyTrackServerInfo(BaseModel):
    """Information about a Dependency Track server."""

    id: str
    name: str
    url: str
    health_status: str
    is_active: bool
    description: Optional[str] = None


class TeamVulnerabilitySettingsResponse(BaseModel):
    """Response schema for team vulnerability settings."""

    vulnerability_provider: str
    custom_dt_server: Optional[DependencyTrackServerInfo] = None
    available_providers: List[VulnerabilityProviderChoice]
    available_dt_servers: List[DependencyTrackServerInfo]
    can_use_custom_dt: bool
    current_plan: str


class UpdateVulnerabilitySettingsRequest(BaseModel):
    """Request to update vulnerability settings."""

    vulnerability_provider: str = Field(..., description="Vulnerability provider ('osv' or 'dependency_track')")
    custom_dt_server_id: Optional[str] = Field(None, description="Custom DT server ID (Enterprise only)")


class ErrorResponse(BaseModel):
    """Standard error response."""

    detail: str


# Manual scan functionality removed - replaced with weekly batch scans


@router.get(
    "/teams/{team_key}/vulnerability-settings",
    response={200: TeamVulnerabilitySettingsResponse, 403: ErrorResponse, 404: ErrorResponse},
    summary="Get team vulnerability scanning settings",
    description=(
        "Retrieve vulnerability scanning configuration for a team including available options based on billing plan."
    ),
    tags=["Vulnerability Scanning"],
)
def get_team_vulnerability_settings(request: HttpRequest, team_key: str):
    """Get vulnerability scanning settings for a team."""
    # Validate team access (any team member can view settings)
    is_valid, error_message, team = _validate_team_access(request, team_key, ["guest", "owner", "admin"])
    if not is_valid:
        return 403, {"detail": error_message}

    # Get or create team settings
    service = VulnerabilityScanningService()
    team_settings = service.get_or_create_team_settings(team)

    # Determine available providers based on billing plan
    available_providers = _get_available_providers(team)

    # Get available DT servers for Enterprise teams
    available_dt_servers = []
    can_use_custom_dt = team.billing_plan == "enterprise"

    if can_use_custom_dt:
        available_dt_servers = [
            DependencyTrackServerInfo(
                id=str(server.id),
                name=server.name,
                url=server.url,
                health_status=server.health_status,
                is_active=server.is_active,
                description=(
                    f"Priority: {server.priority}, Capacity: {server.current_scan_count}/{server.max_concurrent_scans}"
                ),
            )
            for server in DependencyTrackServer.objects.filter(is_active=True).order_by("priority", "name")
        ]

    # Format custom DT server info
    custom_dt_server = None
    if team_settings.custom_dt_server:
        custom_dt_server = DependencyTrackServerInfo(
            id=str(team_settings.custom_dt_server.id),
            name=team_settings.custom_dt_server.name,
            url=team_settings.custom_dt_server.url,
            health_status=team_settings.custom_dt_server.health_status,
            is_active=team_settings.custom_dt_server.is_active,
        )

    return 200, TeamVulnerabilitySettingsResponse(
        vulnerability_provider=team_settings.vulnerability_provider,
        custom_dt_server=custom_dt_server,
        available_providers=available_providers,
        available_dt_servers=available_dt_servers,
        can_use_custom_dt=can_use_custom_dt,
        current_plan=team.billing_plan or "community",
    )


@router.put(
    "/teams/{team_key}/vulnerability-settings",
    response={200: TeamVulnerabilitySettingsResponse, 400: ErrorResponse, 403: ErrorResponse, 404: ErrorResponse},
    summary="Update team vulnerability scanning settings",
    description="Update vulnerability scanning configuration for a team. Only team owners can modify settings.",
    tags=["Vulnerability Scanning"],
)
def update_team_vulnerability_settings(
    request: HttpRequest, team_key: str, payload: UpdateVulnerabilitySettingsRequest
):
    """Update vulnerability scanning settings for a team."""
    # Validate team access (only owners can modify settings)
    is_valid, error_message, team = _validate_team_access(request, team_key, ["owner"])
    if not is_valid:
        return 403, {"detail": error_message}

    # Validate provider choice
    if payload.vulnerability_provider not in ["osv", "dependency_track"]:
        return 400, {"detail": "Invalid vulnerability provider"}

    # Validate billing plan restrictions
    if payload.vulnerability_provider == "dependency_track":
        if not team.billing_plan or team.billing_plan not in ["business", "enterprise"]:
            return 400, {"detail": "Dependency Track is only available for Business and Enterprise plans"}

    # Validate custom DT server restrictions
    custom_dt_server = None
    if payload.custom_dt_server_id:
        if team.billing_plan != "enterprise":
            return 400, {"detail": "Custom Dependency Track servers are only available for Enterprise plans"}

        if payload.vulnerability_provider != "dependency_track":
            return 400, {"detail": "Custom DT server can only be used with Dependency Track provider"}

        try:
            custom_dt_server = DependencyTrackServer.objects.get(id=payload.custom_dt_server_id, is_active=True)
        except DependencyTrackServer.DoesNotExist:
            return 400, {"detail": "Invalid or inactive Dependency Track server"}

    # Update or create team settings
    team_settings, created = TeamVulnerabilitySettings.objects.update_or_create(
        team=team,
        defaults={"vulnerability_provider": payload.vulnerability_provider, "custom_dt_server": custom_dt_server},
    )

    logger.info(
        f"Updated vulnerability settings for team {team.key}: "
        f"provider={payload.vulnerability_provider}, "
        f"custom_server={custom_dt_server.name if custom_dt_server else None}"
    )

    # Return updated settings (reuse the GET logic)
    return get_team_vulnerability_settings(request, team_key)


# Manual scan API endpoint removed - replaced with weekly batch scanning system
# Vulnerability scans are now performed automatically on a weekly schedule
# View scan results using the vulnerability-trends and vulnerability-drill-down endpoints


@router.get(
    "/teams/{team_key}/vulnerability-stats",
    response={200: Dict[str, Any], 403: ErrorResponse, 404: ErrorResponse},
    summary="Get team vulnerability scanning statistics",
    description="Get vulnerability scanning statistics and recent scan results for a team.",
    tags=["Vulnerability Scanning"],
)
def get_team_vulnerability_stats(
    request: HttpRequest,
    team_key: str,
    component_id: Optional[str] = Query(None, description="Filter to specific component"),
    product_id: Optional[str] = Query(None, description="Filter to specific product"),
    release_id: Optional[str] = Query(None, description="Filter to specific release/version"),
    latest_sbom_only: bool = Query(False, description="For component view: only show vulnerabilities from latest SBOM"),
):
    """Get vulnerability scanning statistics for a team."""
    try:
        team_id = token_to_number(team_key)
        team = get_object_or_404(Team, pk=team_id)

        # Check if user is a member of this team
        if not Member.objects.filter(user=request.user, team=team).exists():
            return 403, {"detail": "Access denied"}

        # Get components for this team
        from core.models import Component

        components = Component.objects.filter(team=team)

        # Get recent vulnerability scan results
        recent_results_query = VulnerabilityScanResult.objects.filter(sbom__component__team=team)

        # Filter by product if specified
        if product_id:
            recent_results_query = recent_results_query.filter(sbom__component__projects__products__id=product_id)

        # Filter by release if specified
        if release_id:
            # Filter to SBOMs that are part of the specified release
            from core.models import ReleaseArtifact

            sbom_ids_in_release = ReleaseArtifact.objects.filter(release_id=release_id, sbom__isnull=False).values_list(
                "sbom_id", flat=True
            )
            recent_results_query = recent_results_query.filter(sbom_id__in=sbom_ids_in_release)

        # Filter by component if specified
        if component_id:
            recent_results_query = recent_results_query.filter(sbom__component_id=component_id)

            # If latest_sbom_only is requested, filter to only the latest SBOM
            if latest_sbom_only:
                from core.models import Component

                try:
                    component = Component.objects.get(id=component_id)
                    latest_sbom = component.latest_sbom
                    if latest_sbom:
                        # Only include results from the latest SBOM
                        recent_results_query = recent_results_query.filter(sbom_id=latest_sbom.id)
                    else:
                        # No SBOMs exist for this component, return empty results
                        recent_results_query = recent_results_query.none()
                except Component.DoesNotExist:
                    recent_results_query = recent_results_query.none()

        recent_results = recent_results_query.order_by("-created_at")[:10]

        # Calculate statistics
        total_scans = recent_results.count()
        provider_stats = {}
        total_vulnerabilities = 0

        for result in recent_results:
            provider = result.provider
            if provider not in provider_stats:
                provider_stats[provider] = {"count": 0, "vulnerabilities": 0}

            provider_stats[provider]["count"] += 1
            vuln_count = result.vulnerability_count.get("total", 0) if result.vulnerability_count else 0
            provider_stats[provider]["vulnerabilities"] += vuln_count
            total_vulnerabilities += vuln_count

        # Get DT mapping info if applicable
        dt_mappings = []
        if team.billing_plan in ["business", "enterprise"]:
            mappings = ComponentDependencyTrackMapping.objects.filter(component__team=team).select_related(
                "dt_server", "component"
            )

            dt_mappings = [
                {
                    "component_name": mapping.component.name,
                    "dt_server_name": mapping.dt_server.name,
                    "dt_project_name": mapping.dt_project_name,
                    "last_upload": mapping.last_sbom_upload.isoformat() if mapping.last_sbom_upload else None,
                    "last_sync": mapping.last_metrics_sync.isoformat() if mapping.last_metrics_sync else None,
                }
                for mapping in mappings
            ]

        return 200, {
            "total_components": components.count(),
            "total_scans": total_scans,
            "total_vulnerabilities": total_vulnerabilities,
            "provider_stats": provider_stats,
            "dt_mappings": dt_mappings,
            "recent_results": [
                {
                    "id": str(result.id),
                    "sbom_id": str(result.sbom.id),
                    "sbom_name": result.sbom.name,
                    "sbom_version": result.sbom.version,
                    "component_name": result.sbom.component.name,
                    "provider": result.provider,
                    "scan_trigger": result.scan_trigger,
                    "vulnerability_count": result.vulnerability_count,
                    "total_vulnerabilities": result.total_vulnerabilities,
                    "critical_vulnerabilities": result.critical_vulnerabilities,
                    "high_vulnerabilities": result.high_vulnerabilities,
                    "medium_vulnerabilities": result.medium_vulnerabilities,
                    "low_vulnerabilities": result.low_vulnerabilities,
                    "scan_date": result.created_at.isoformat(),
                    "created_at": result.created_at.isoformat(),
                }
                for result in recent_results
            ],
        }

    except ValueError:
        return 404, {"detail": "Team not found"}


@router.get(
    "/teams/{team_key}/vulnerability-timeseries",
    response={200: Dict[str, Any], 403: ErrorResponse, 404: ErrorResponse},
    summary="Get vulnerability scanning time series data",
    description="Get historical vulnerability data for time series charts including trends by severity and provider.",
    tags=["Vulnerability Scanning"],
)
def get_team_vulnerability_timeseries(
    request: HttpRequest,
    team_key: str,
    component_id: Optional[str] = Query(None, description="Filter to specific component"),
    product_id: Optional[str] = Query(None, description="Filter to specific product"),
    release_id: Optional[str] = Query(None, description="Filter to specific release/version"),
    latest_sbom_only: bool = Query(
        False, description="For component view: only show vulnerabilities from latest SBOM over time"
    ),
    days: int = Query(30, description="Number of days to include in time series", ge=7, le=365),
):
    """Get vulnerability time series data for charts."""
    try:
        team_id = token_to_number(team_key)
        team = get_object_or_404(Team, pk=team_id)

        # Check if user is a member of this team
        if not Member.objects.filter(user=request.user, team=team).exists():
            return 403, {"detail": "Access denied"}

        from collections import defaultdict
        from datetime import timedelta

        from django.utils import timezone

        end_date = timezone.now()
        start_date = end_date - timedelta(days=days)

        # Base query for vulnerability scan results
        results_query = VulnerabilityScanResult.objects.filter(
            sbom__component__team=team, created_at__gte=start_date, created_at__lte=end_date
        ).select_related("sbom__component")

        # Filter by product if specified
        if product_id:
            results_query = results_query.filter(sbom__component__projects__products__id=product_id)

        # Filter by release if specified
        if release_id:
            # Filter to SBOMs that are part of the specified release
            from core.models import ReleaseArtifact

            sbom_ids_in_release = ReleaseArtifact.objects.filter(release_id=release_id, sbom__isnull=False).values_list(
                "sbom_id", flat=True
            )
            results_query = results_query.filter(sbom_id__in=sbom_ids_in_release)

        # Filter by component if specified
        if component_id:
            results_query = results_query.filter(sbom__component_id=component_id)

            # If latest_sbom_only is requested, filter to only the latest SBOM at each point in time
            if latest_sbom_only:
                from core.models import Component

                try:
                    component = Component.objects.get(id=component_id)
                    latest_sbom = component.latest_sbom
                    if latest_sbom:
                        # Only include results from the latest SBOM
                        results_query = results_query.filter(sbom_id=latest_sbom.id)
                    else:
                        # No SBOMs exist for this component, return empty results
                        results_query = results_query.none()
                except Component.DoesNotExist:
                    results_query = results_query.none()

        # Get all results ordered by time
        results = list(results_query.order_by("created_at"))

        # Group results by day
        daily_data = defaultdict(
            lambda: {
                "scans_count": 0,
                "total_vulnerabilities": 0,
                "severities": {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0},
                "providers": defaultdict(lambda: {"scans": 0, "vulnerabilities": 0}),
            }
        )

        for result in results:
            day_key = result.created_at.date().isoformat()
            day_data = daily_data[day_key]

            day_data["scans_count"] += 1

            # Add vulnerability counts
            vuln_count = result.vulnerability_count or {}
            total_vulns = vuln_count.get("total", 0)
            day_data["total_vulnerabilities"] += total_vulns

            # Add severity breakdown
            for severity in ["critical", "high", "medium", "low", "info"]:
                count = vuln_count.get(severity, 0)
                day_data["severities"][severity] += count

            # Add provider stats
            provider = result.provider
            day_data["providers"][provider]["scans"] += 1
            day_data["providers"][provider]["vulnerabilities"] += total_vulns

        # Convert to time series format
        time_series = []
        current_date = start_date.date()
        while current_date <= end_date.date():
            day_key = current_date.isoformat()
            day_data = daily_data.get(
                day_key,
                {
                    "scans_count": 0,
                    "total_vulnerabilities": 0,
                    "severities": {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0},
                    "providers": {},
                },
            )

            time_series.append(
                {
                    "date": day_key,
                    "scans_count": day_data["scans_count"],
                    "total_vulnerabilities": day_data["total_vulnerabilities"],
                    "severities": day_data["severities"],
                    "providers": dict(day_data["providers"]),
                }
            )

            current_date += timedelta(days=1)

        # Calculate summary statistics
        total_scans = sum(day["scans_count"] for day in time_series)
        total_vulnerabilities = sum(day["total_vulnerabilities"] for day in time_series)

        # Get severity totals
        severity_totals = {
            "critical": sum(day["severities"]["critical"] for day in time_series),
            "high": sum(day["severities"]["high"] for day in time_series),
            "medium": sum(day["severities"]["medium"] for day in time_series),
            "low": sum(day["severities"]["low"] for day in time_series),
            "info": sum(day["severities"]["info"] for day in time_series),
        }

        # Get provider summary
        provider_summary = defaultdict(lambda: {"scans": 0, "vulnerabilities": 0})
        for day in time_series:
            for provider, stats in day["providers"].items():
                provider_summary[provider]["scans"] += stats["scans"]
                provider_summary[provider]["vulnerabilities"] += stats["vulnerabilities"]

        return 200, {
            "time_series": time_series,
            "summary": {
                "total_scans": total_scans,
                "total_vulnerabilities": total_vulnerabilities,
                "severity_totals": severity_totals,
                "provider_summary": dict(provider_summary),
                "date_range": {
                    "start": start_date.date().isoformat(),
                    "end": end_date.date().isoformat(),
                    "days": days,
                },
            },
        }

    except ValueError:
        return 404, {"detail": "Team not found"}


@router.get(
    "/teams/{team_key}/vulnerability-drill-down",
    response={200: Dict[str, Any], 403: ErrorResponse, 404: ErrorResponse},
    summary="Get detailed vulnerability drill-down data",
    description=(
        "Get detailed breakdown of vulnerabilities with components, "
        "SBOMs, and vulnerability details for drill-down views."
    ),
    tags=["Vulnerability Scanning"],
)
def get_team_vulnerability_drill_down(
    request: HttpRequest,
    team_key: str,
    filter_type: str = Query(..., description="Filter type: 'date', 'severity', or 'provider'"),
    filter_value: str = Query(..., description="Filter value based on filter_type"),
    component_id: Optional[str] = Query(None, description="Filter to specific component"),
    product_id: Optional[str] = Query(None, description="Filter to specific product"),
    release_id: Optional[str] = Query(None, description="Filter to specific release/version"),
    latest_sbom_only: bool = Query(False, description="For component view: only show vulnerabilities from latest SBOM"),
    days: int = Query(30, description="Number of days for context", ge=7, le=365),
):
    """Get detailed vulnerability drill-down data for charts using standardized storage."""
    try:
        team_id = token_to_number(team_key)
        team = get_object_or_404(Team, pk=team_id)

        # Check if user is a member of this team
        if not Member.objects.filter(user=request.user, team=team).exists():
            return 403, {"detail": "Access denied"}

        from collections import defaultdict
        from datetime import datetime, timedelta

        from django.utils import timezone

        end_date = timezone.now()
        start_date = end_date - timedelta(days=days)

        # Base query for vulnerability scan results using latest results per SBOM
        (
            VulnerabilityScanResult.objects.filter(
                sbom__component__team=team, created_at__gte=start_date, created_at__lte=end_date
            )
            .values("sbom", "provider")
            .annotate(latest_created_at=models.Max("created_at"))
        )

        # Get only the latest results for each SBOM/provider combination
        results_query = VulnerabilityScanResult.objects.filter(
            sbom__component__team=team, created_at__gte=start_date, created_at__lte=end_date
        ).select_related("sbom__component")

        # Filter by product if specified
        if product_id:
            results_query = results_query.filter(sbom__component__projects__products__id=product_id)

        # Filter by release if specified
        if release_id:
            # Filter to SBOMs that are part of the specified release
            from core.models import ReleaseArtifact

            sbom_ids_in_release = ReleaseArtifact.objects.filter(release_id=release_id, sbom__isnull=False).values_list(
                "sbom_id", flat=True
            )
            results_query = results_query.filter(sbom_id__in=sbom_ids_in_release)

        # Filter by component if specified
        if component_id:
            results_query = results_query.filter(sbom__component_id=component_id)

            # If latest_sbom_only is requested, filter to only the latest SBOM
            if latest_sbom_only:
                from core.models import Component

                try:
                    component = Component.objects.get(id=component_id)
                    latest_sbom = component.latest_sbom
                    if latest_sbom:
                        # Only include results from the latest SBOM
                        results_query = results_query.filter(sbom_id=latest_sbom.id)
                    else:
                        # No SBOMs exist for this component, return empty results
                        results_query = results_query.none()
                except Component.DoesNotExist:
                    results_query = results_query.none()

        # Apply specific filters based on filter_type
        if filter_type == "date":
            # Filter to specific date
            target_date = datetime.fromisoformat(filter_value).date()
            results_query = results_query.filter(created_at__date=target_date)
        elif filter_type == "severity":
            # Filter results that have vulnerabilities of the specified severity using denormalized counts
            severity_field_map = {
                "critical": "critical_vulnerabilities",
                "high": "high_vulnerabilities",
                "medium": "medium_vulnerabilities",
                "low": "low_vulnerabilities",
            }
            if filter_value in severity_field_map:
                filter_kwargs = {f"{severity_field_map[filter_value]}__gt": 0}
                results_query = results_query.filter(**filter_kwargs)
        elif filter_type == "provider":
            # Filter by provider
            results_query = results_query.filter(provider=filter_value)

        # Get filtered results
        results = list(results_query.order_by("-created_at"))

        # Aggregate data by component
        components_data = defaultdict(
            lambda: {
                "id": "",
                "name": "",
                "sbom_count": 0,
                "vulnerability_count": 0,
                "severities": {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0},
            }
        )

        # Aggregate data by SBOM
        sboms_data = defaultdict(
            lambda: {
                "id": "",
                "name": "",
                "format": "",
                "format_version": "",
                "component_name": "",
                "vulnerability_count": 0,
                "severities": {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0},
                "last_scan_date": None,
            }
        )

        # Collect all vulnerabilities for detailed view
        all_vulnerabilities = []
        vulnerability_counts = defaultdict(int)

        for result in results:
            component = result.sbom.component
            sbom = result.sbom

            # Update component data
            comp_key = str(component.id)
            comp_data = components_data[comp_key]
            comp_data["id"] = str(component.id)
            comp_data["name"] = component.name
            comp_data["sbom_count"] += 1

            # Update SBOM data
            sbom_key = str(sbom.id)
            sbom_data = sboms_data[sbom_key]
            sbom_data["id"] = str(sbom.id)
            sbom_data["name"] = f"{sbom.name}{f' {sbom.version}' if sbom.version else ''}"
            sbom_data["format"] = sbom.format or "Unknown"
            sbom_data["format_version"] = sbom.format_version or ""
            sbom_data["component_name"] = component.name
            sbom_data["last_scan_date"] = result.created_at.isoformat()

            # Use denormalized counts for performance
            comp_data["vulnerability_count"] += result.total_vulnerabilities
            sbom_data["vulnerability_count"] += result.total_vulnerabilities

            # Update severity counts using denormalized fields
            comp_data["severities"]["critical"] += result.critical_vulnerabilities
            comp_data["severities"]["high"] += result.high_vulnerabilities
            comp_data["severities"]["medium"] += result.medium_vulnerabilities
            comp_data["severities"]["low"] += result.low_vulnerabilities

            sbom_data["severities"]["critical"] += result.critical_vulnerabilities
            sbom_data["severities"]["high"] += result.high_vulnerabilities
            sbom_data["severities"]["medium"] += result.medium_vulnerabilities
            sbom_data["severities"]["low"] += result.low_vulnerabilities

            # Extract individual vulnerabilities from standardized findings (direct array format)
            findings = result.findings or []

            # Handle both old nested format and new direct array format for backward compatibility
            if isinstance(findings, dict) and "vulnerabilities" in findings:
                # Old nested format
                vulnerabilities_list = findings["vulnerabilities"]
            elif isinstance(findings, list):
                # New standardized direct array format
                vulnerabilities_list = findings
            else:
                vulnerabilities_list = []

            for vuln in vulnerabilities_list:
                vuln_id = vuln.get("id", "unknown")
                if vuln_id and vuln_id != "unknown":
                    if vuln_id not in vulnerability_counts:
                        # Add to detailed vulnerabilities list
                        # Extract external URL from references or provider specific data
                        external_url = None
                        references = vuln.get("references", [])
                        if references:
                            if isinstance(references[0], dict):
                                external_url = references[0].get("url")
                            elif isinstance(references[0], str):
                                external_url = references[0]

                        if not external_url:
                            provider_specific = vuln.get("provider_specific", {})
                            external_url = provider_specific.get("url")

                        vulnerability_detail = {
                            "id": vuln_id,
                            "summary": vuln.get("title") or vuln.get("summary", ""),
                            "severity": vuln.get("severity", "unknown").upper(),
                            "affected_components": 1,
                            "external_url": external_url,
                            "component_name": vuln.get("component", {}).get("name", "Unknown"),
                            "cvss_score": vuln.get("cvss_score"),
                        }
                        all_vulnerabilities.append(vulnerability_detail)
                        vulnerability_counts[vuln_id] = 1
                    else:
                        # Increment affected components count
                        vulnerability_counts[vuln_id] += 1
                        for v in all_vulnerabilities:
                            if v["id"] == vuln_id:
                                v["affected_components"] = vulnerability_counts[vuln_id]
                                break

        # Convert to lists and sort
        components_list = sorted(list(components_data.values()), key=lambda x: x["vulnerability_count"], reverse=True)

        sboms_list = sorted(list(sboms_data.values()), key=lambda x: x["vulnerability_count"], reverse=True)

        # Sort vulnerabilities by severity and affected components
        severity_order = {"CRITICAL": 0, "HIGH": 1, "MEDIUM": 2, "LOW": 3, "INFO": 4, "UNKNOWN": 5}
        vulnerabilities_list = sorted(
            all_vulnerabilities, key=lambda x: (severity_order.get(x["severity"], 5), -x["affected_components"])
        )

        return 200, {
            "filter_type": filter_type,
            "filter_value": filter_value,
            "total_results": len(results),
            "components": components_list,
            "sboms": sboms_list,
            "vulnerabilities": vulnerabilities_list,
            "summary": {
                "total_components": len(components_list),
                "total_sboms": len(sboms_list),
                "total_vulnerabilities": len(vulnerabilities_list),
                "date_range": {
                    "start": start_date.date().isoformat(),
                    "end": end_date.date().isoformat(),
                    "days": days,
                },
            },
        }

    except ValueError:
        return 404, {"detail": "Team not found"}


@router.get(
    "/teams/{team_key}/vulnerability-trends",
    response={200: Dict[str, Any], 403: ErrorResponse, 404: ErrorResponse},
    summary="Get vulnerability trends over time for time series analysis",
    description="Get historical vulnerability trends showing changes over time for dashboard charts and analysis.",
    tags=["Vulnerability Scanning"],
)
def get_team_vulnerability_trends(
    request: HttpRequest,
    team_key: str,
    days: int = Query(30, description="Number of days to analyze (default: 30)"),
    granularity: str = Query("day", description="Time granularity: 'day', 'week', or 'month'"),
    component_id: Optional[str] = Query(None, description="Filter by specific component ID"),
    provider: Optional[str] = Query(None, description="Filter by vulnerability provider"),
):
    """
    Get vulnerability trends over time for comprehensive time series analysis.

    Returns aggregated vulnerability data points over the specified time period,
    grouped by the requested granularity (day/week/month).
    """
    from datetime import timedelta

    from django.db.models import Avg, Count
    from django.db.models.functions import TruncDate, TruncMonth, TruncWeek

    from core.utils import verify_item_access
    from teams.models import Team

    try:
        # Get team and verify access
        team = get_object_or_404(Team, key=team_key)

        if not verify_item_access(request, team, ["guest", "owner", "admin"]):
            return 403, {"detail": "Access denied"}

        # Calculate date range
        from django.utils import timezone

        end_date = timezone.now()
        start_date = end_date - timedelta(days=days)

        # Build base queryset
        queryset = VulnerabilityScanResult.objects.filter(
            sbom__component__team=team, created_at__gte=start_date, created_at__lte=end_date
        )

        # Apply filters
        if component_id:
            queryset = queryset.filter(sbom__component_id=component_id)
        if provider:
            queryset = queryset.filter(provider=provider)

        # Choose aggregation function based on granularity
        if granularity == "week":
            trunc_func = TruncWeek
        elif granularity == "month":
            trunc_func = TruncMonth
        else:  # default to day
            trunc_func = TruncDate

        # Aggregate data by time period
        trends = (
            queryset.annotate(period=trunc_func("created_at"))
            .values("period")
            .annotate(
                scan_count=Count("id"),
                avg_total_vulnerabilities=Avg("total_vulnerabilities"),
                avg_critical_vulnerabilities=Avg("critical_vulnerabilities"),
                avg_high_vulnerabilities=Avg("high_vulnerabilities"),
                avg_medium_vulnerabilities=Avg("medium_vulnerabilities"),
                avg_low_vulnerabilities=Avg("low_vulnerabilities"),
                max_total_vulnerabilities=models.Max("total_vulnerabilities"),
                min_total_vulnerabilities=models.Min("total_vulnerabilities"),
                total_scans=Count("id"),
            )
            .order_by("period")
        )

        # Get provider breakdown for the period
        provider_trends = queryset.values("provider").annotate(
            total_scans=Count("id"), avg_vulnerabilities=Avg("total_vulnerabilities")
        )

        # Get component breakdown if not filtering by component
        component_trends = []
        if not component_id:
            component_trends = (
                queryset.values("sbom__component__name", "sbom__component_id")
                .annotate(
                    total_scans=Count("id"),
                    avg_vulnerabilities=Avg("total_vulnerabilities"),
                    latest_scan=models.Max("created_at"),
                )
                .order_by("-avg_vulnerabilities")[:10]
            )  # Top 10 components by avg vulns

        return 200, {
            "time_series": [
                {
                    "date": item["period"].isoformat() if item["period"] else None,
                    "scan_count": item["scan_count"] or 0,
                    "avg_total_vulnerabilities": round(item["avg_total_vulnerabilities"] or 0, 1),
                    "avg_critical_vulnerabilities": round(item["avg_critical_vulnerabilities"] or 0, 1),
                    "avg_high_vulnerabilities": round(item["avg_high_vulnerabilities"] or 0, 1),
                    "avg_medium_vulnerabilities": round(item["avg_medium_vulnerabilities"] or 0, 1),
                    "avg_low_vulnerabilities": round(item["avg_low_vulnerabilities"] or 0, 1),
                    "max_total_vulnerabilities": item["max_total_vulnerabilities"] or 0,
                    "min_total_vulnerabilities": item["min_total_vulnerabilities"] or 0,
                }
                for item in trends
            ],
            "provider_breakdown": [
                {
                    "provider": item["provider"],
                    "total_scans": item["total_scans"],
                    "avg_vulnerabilities": round(item["avg_vulnerabilities"] or 0, 1),
                }
                for item in provider_trends
            ],
            "component_breakdown": [
                {
                    "component_name": item["sbom__component__name"],
                    "component_id": item["sbom__component_id"],
                    "total_scans": item["total_scans"],
                    "avg_vulnerabilities": round(item["avg_vulnerabilities"] or 0, 1),
                    "latest_scan": item["latest_scan"].isoformat() if item["latest_scan"] else None,
                }
                for item in component_trends
            ],
            "summary": {
                "total_scans": queryset.count(),
                "date_range": {"start": start_date.isoformat(), "end": end_date.isoformat(), "days": days},
                "granularity": granularity,
                "filters": {"component_id": component_id, "provider": provider},
            },
        }

    except Exception as e:
        logger.error(f"Failed to get vulnerability trends for team {team_key}: {e}")
        return 400, {"detail": "Failed to get vulnerability trends"}


@router.get(
    "/teams/{team_key}/vulnerability-heatmap",
    response={200: Dict[str, Any], 403: ErrorResponse, 404: ErrorResponse},
    summary="Get vulnerability heatmap data for visual analysis",
    description="Get vulnerability density data across components and time periods for heatmap visualizations.",
    tags=["Vulnerability Scanning"],
)
def get_team_vulnerability_heatmap(
    request: HttpRequest,
    team_key: str,
    days: int = Query(30, description="Number of days to analyze (default: 30)"),
    severity_focus: str = Query("total", description="Focus severity: 'total', 'critical', 'high', 'medium', 'low'"),
):
    """
    Get vulnerability heatmap data showing density across components and time.

    Returns a matrix-style dataset perfect for heatmap visualizations,
    showing vulnerability density patterns across different components over time.
    """
    from datetime import timedelta

    from django.db.models import Avg, Count, Max
    from django.db.models.functions import TruncDate

    from core.utils import verify_item_access
    from teams.models import Team

    try:
        # Get team and verify access
        team = get_object_or_404(Team, key=team_key)

        if not verify_item_access(request, team, ["guest", "owner", "admin"]):
            return 403, {"detail": "Access denied"}

        # Calculate date range
        from django.utils import timezone

        end_date = timezone.now()
        start_date = end_date - timedelta(days=days)

        # Map severity focus to field
        severity_field_map = {
            "total": "total_vulnerabilities",
            "critical": "critical_vulnerabilities",
            "high": "high_vulnerabilities",
            "medium": "medium_vulnerabilities",
            "low": "low_vulnerabilities",
        }

        severity_field = severity_field_map.get(severity_focus, "total_vulnerabilities")

        # Get heatmap data: component x date matrix
        heatmap_data = (
            VulnerabilityScanResult.objects.filter(
                sbom__component__team=team, created_at__gte=start_date, created_at__lte=end_date
            )
            .annotate(date=TruncDate("created_at"))
            .values("sbom__component__name", "sbom__component_id", "date")
            .annotate(
                avg_vulnerabilities=Avg(severity_field), max_vulnerabilities=Max(severity_field), scan_count=Count("id")
            )
            .order_by("sbom__component__name", "date")
        )

        # Transform into matrix format
        components = {}
        dates = set()

        for item in heatmap_data:
            component_name = item["sbom__component__name"]
            component_id = item["sbom__component_id"]
            date = item["date"]

            if component_name not in components:
                components[component_name] = {
                    "component_id": component_id,
                    "component_name": component_name,
                    "dates": {},
                }

            components[component_name]["dates"][date.isoformat()] = {
                "avg_vulnerabilities": round(item["avg_vulnerabilities"] or 0, 1),
                "max_vulnerabilities": item["max_vulnerabilities"] or 0,
                "scan_count": item["scan_count"],
            }

            dates.add(date.isoformat())

        # Fill in missing dates with zeros
        sorted_dates = sorted(list(dates))
        for component_data in components.values():
            for date in sorted_dates:
                if date not in component_data["dates"]:
                    component_data["dates"][date] = {
                        "avg_vulnerabilities": 0,
                        "max_vulnerabilities": 0,
                        "scan_count": 0,
                    }

        # Get overall statistics
        overall_stats = VulnerabilityScanResult.objects.filter(
            sbom__component__team=team, created_at__gte=start_date, created_at__lte=end_date
        ).aggregate(
            total_scans=Count("id"),
            avg_vulnerabilities=Avg(severity_field),
            max_vulnerabilities=Max(severity_field),
            component_count=Count("sbom__component", distinct=True),
        )

        return 200, {
            "heatmap_data": list(components.values()),
            "dates": sorted_dates,
            "components": [
                {"id": comp_data["component_id"], "name": comp_data["component_name"]}
                for comp_data in components.values()
            ],
            "statistics": {
                "total_scans": overall_stats["total_scans"] or 0,
                "avg_vulnerabilities": round(overall_stats["avg_vulnerabilities"] or 0, 1),
                "max_vulnerabilities": overall_stats["max_vulnerabilities"] or 0,
                "component_count": overall_stats["component_count"] or 0,
                "severity_focus": severity_focus,
                "date_range": {"start": start_date.isoformat(), "end": end_date.isoformat(), "days": days},
            },
        }

    except Exception as e:
        logger.error(f"Failed to get vulnerability heatmap for team {team_key}: {e}")
        return 400, {"detail": "Failed to get vulnerability heatmap"}


@router.get(
    "/teams/{team_key}/products-releases",
    response={200: Dict[str, Any], 403: ErrorResponse, 404: ErrorResponse},
    summary="Get products and releases for vulnerability filtering",
    description="Get list of products and their releases for dashboard filtering controls.",
    tags=["Vulnerability Scanning"],
)
def get_team_products_releases(request: HttpRequest, team_key: str):
    """Get products and releases for dropdown controls."""
    try:
        team_id = token_to_number(team_key)
        team = get_object_or_404(Team, pk=team_id)

        # Check if user is a member of this team
        if not Member.objects.filter(user=request.user, team=team).exists():
            return 403, {"detail": "Access denied"}

        from core.models import Product, Release

        # Get all products for this team
        products = Product.objects.filter(team=team).order_by("name")

        products_data = []
        for product in products:
            # Get releases for this product
            releases = Release.objects.filter(product=product).order_by("-created_at")

            releases_data = [
                {
                    "id": str(release.id),
                    "name": release.name,
                    "description": release.description,
                    "is_latest": release.is_latest,
                    "is_prerelease": release.is_prerelease,
                    "created_at": release.created_at.isoformat(),
                }
                for release in releases
            ]

            products_data.append(
                {
                    "id": str(product.id),
                    "name": product.name,
                    "description": product.description,
                    "releases": releases_data,
                }
            )

        return 200, {"products": products_data}

    except Exception as e:
        logger.error(f"Failed to get products and releases for team {team_key}: {e}")
        return 400, {"detail": "Failed to get products and releases"}


def _get_available_providers(team: Team) -> List[VulnerabilityProviderChoice]:
    """Get available vulnerability providers based on team's billing plan."""
    providers = [
        VulnerabilityProviderChoice(
            value="osv",
            label="OSV (Google Open Source Vulnerabilities)",
            description="Free, comprehensive vulnerability database from Google",
            available=True,
        )
    ]

    # DT is available for Business and Enterprise plans
    if team.billing_plan in ["business", "enterprise"]:
        providers.append(
            VulnerabilityProviderChoice(
                value="dependency_track",
                label="Dependency Track",
                description="Advanced vulnerability management with detailed metrics and analysis",
                available=True,
                plan_required="business",
            )
        )
    else:
        providers.append(
            VulnerabilityProviderChoice(
                value="dependency_track",
                label="Dependency Track",
                description="Advanced vulnerability management (Business/Enterprise only)",
                available=False,
                plan_required="business",
            )
        )

    return providers
