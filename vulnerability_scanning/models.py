"""Models for vulnerability scanning integration."""

import uuid
from typing import Any, Dict

from django.apps import apps
from django.core.exceptions import ValidationError
from django.db import models


def validate_vulnerability_count(value):
    """Validate vulnerability_count JSON field structure."""
    if not isinstance(value, dict):
        raise ValidationError("Vulnerability count must be a dictionary")

    required_keys = {"total", "critical", "high", "medium", "low"}
    if not required_keys.issubset(value.keys()):
        missing_keys = required_keys - value.keys()
        raise ValidationError(f"Vulnerability count must contain keys: {missing_keys}")

    # Validate that all values are non-negative integers
    for key, count in value.items():
        if key in required_keys:
            if not isinstance(count, int) or count < 0:
                raise ValidationError(f'Vulnerability count for "{key}" must be a non-negative integer')


def validate_findings_array(value):
    """Validate findings JSON field structure."""
    if not isinstance(value, list):
        raise ValidationError("Findings must be a list")

    # Basic validation that each finding is a dictionary
    for i, finding in enumerate(value):
        if not isinstance(finding, dict):
            raise ValidationError(f"Finding at index {i} must be a dictionary")

        # Validate required fields in standardized format
        required_fields = {"id", "severity", "component"}
        if not required_fields.issubset(finding.keys()):
            missing_fields = required_fields - finding.keys()
            raise ValidationError(f"Finding at index {i} missing required fields: {missing_fields}")


class DependencyTrackServer(models.Model):
    """
    Represents a Dependency Track server instance in the pool.

    Admin-managed pool of DT servers for load balancing and scaling.
    """

    class Meta:
        db_table = apps.get_app_config("vulnerability_scanning").name + "_dt_servers"
        indexes = [
            models.Index(fields=["is_active", "priority"]),
            models.Index(fields=["url"]),
        ]
        ordering = ["priority", "name"]

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=255, help_text="Friendly name for this DT server")
    url = models.URLField(max_length=500, unique=True, help_text="Base URL of the Dependency Track server")
    api_key = models.CharField(max_length=255, help_text="API key for authentication")
    is_active = models.BooleanField(default=True, help_text="Whether this server is available for use")
    priority = models.IntegerField(default=100, help_text="Lower numbers = higher priority for load balancing")
    max_concurrent_scans = models.IntegerField(default=10, help_text="Maximum concurrent SBOM uploads/scans")
    current_scan_count = models.IntegerField(default=0, help_text="Current number of active scans")
    last_health_check = models.DateTimeField(null=True, blank=True)
    health_status = models.CharField(
        max_length=20,
        choices=[
            ("healthy", "Healthy"),
            ("degraded", "Degraded"),
            ("unhealthy", "Unhealthy"),
            ("unknown", "Unknown"),
        ],
        default="unknown",
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self) -> str:
        """Return string representation."""
        return f"{self.name} ({self.url})"

    def clean(self) -> None:
        """Validate the model data."""
        super().clean()
        if self.priority < 1:
            raise ValidationError({"priority": "Priority must be positive"})
        if self.max_concurrent_scans < 1:
            raise ValidationError({"max_concurrent_scans": "Must allow at least 1 concurrent scan"})

    @property
    def is_available_for_scan(self) -> bool:
        """Check if server can accept new scans."""
        return (
            self.is_active
            and self.health_status in ["healthy", "degraded"]
            and self.current_scan_count < self.max_concurrent_scans
        )

    def increment_scan_count(self) -> bool:
        """
        Atomically increment the scan count if under the limit.

        Returns:
            bool: True if successfully incremented, False if at capacity
        """
        from django.db.models import F

        # Use atomic update to prevent race conditions
        rows_updated = DependencyTrackServer.objects.filter(
            id=self.id, current_scan_count__lt=F("max_concurrent_scans")
        ).update(current_scan_count=F("current_scan_count") + 1)

        if rows_updated > 0:
            # Refresh the instance to get the updated value
            self.refresh_from_db(fields=["current_scan_count"])
            return True
        return False

    def decrement_scan_count(self) -> None:
        """
        Atomically decrement the scan count.

        Ensures the count doesn't go below zero.
        """
        from django.db.models import Case, F, Value, When

        # Use atomic update with conditional logic to prevent negative values
        DependencyTrackServer.objects.filter(id=self.id).update(
            current_scan_count=Case(When(current_scan_count__gt=0, then=F("current_scan_count") - 1), default=Value(0))
        )

        # Refresh the instance to get the updated value
        self.refresh_from_db(fields=["current_scan_count"])


class TeamVulnerabilitySettings(models.Model):
    """
    Team-specific vulnerability scanning configuration.

    Allows Business/Enterprise teams to configure their vulnerability scanning preferences:
    - Business teams: Can choose OSV or Dependency Track (shared pool only)
    - Enterprise teams: Can choose OSV, Dependency Track (shared pool), or bring their own DT instance
    """

    class Meta:
        db_table = apps.get_app_config("vulnerability_scanning").name + "_team_settings"
        indexes = [models.Index(fields=["team"])]

    VULNERABILITY_PROVIDER_CHOICES = [
        ("osv", "OSV (Google Open Source Vulnerabilities)"),
        ("dependency_track", "Dependency Track"),
    ]

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    team = models.OneToOneField("teams.Team", on_delete=models.CASCADE, related_name="vulnerability_settings")
    vulnerability_provider = models.CharField(
        max_length=20,
        choices=VULNERABILITY_PROVIDER_CHOICES,
        default="osv",
        help_text="Choose between OSV and Dependency Track for vulnerability scanning",
    )

    # Custom DT instance (Enterprise feature)
    custom_dt_server = models.ForeignKey(
        DependencyTrackServer,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="teams_using_custom",
        help_text="Custom Dependency Track server (Enterprise only). Business plans use the shared server pool.",
    )

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self) -> str:
        """Return string representation."""
        return f"{self.team.name} - {self.get_vulnerability_provider_display()}"

    def clean(self) -> None:
        """Validate team settings."""
        super().clean()
        # Only Business/Enterprise teams can use DT
        if self.vulnerability_provider == "dependency_track":
            if not self.team.billing_plan or self.team.billing_plan not in ["business", "enterprise"]:
                raise ValidationError(
                    {"vulnerability_provider": "Dependency Track is only available for Business and Enterprise plans"}
                )

        # Only Enterprise teams can use custom DT servers
        if self.custom_dt_server:
            if self.team.billing_plan != "enterprise":
                raise ValidationError(
                    {"custom_dt_server": "Custom Dependency Track servers are only available for Enterprise plans"}
                )

            # Ensure the vulnerability provider is set to dependency_track if custom server is specified
            if self.vulnerability_provider != "dependency_track":
                raise ValidationError(
                    {
                        "custom_dt_server": (
                            "Custom DT server can only be used when vulnerability provider "
                            "is set to Dependency Track"
                        )
                    }
                )


class ComponentDependencyTrackMapping(models.Model):
    """
    Maps sbomify Components to Dependency Track projects.

    Provides persistent mapping with round-robin load balancing across DT server pool.
    """

    class Meta:
        db_table = apps.get_app_config("vulnerability_scanning").name + "_component_mappings"
        indexes = [
            models.Index(fields=["component"]),
            models.Index(fields=["dt_server", "dt_project_uuid"]),
        ]
        unique_together = [("component", "dt_server")]

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    component = models.ForeignKey("core.Component", on_delete=models.CASCADE, related_name="dependency_track_mappings")
    dt_server = models.ForeignKey(DependencyTrackServer, on_delete=models.CASCADE, related_name="component_mappings")
    dt_project_uuid = models.UUIDField(help_text="UUID of the project in Dependency Track")
    dt_project_name = models.CharField(max_length=255, help_text="Name of the project in DT")

    # Caching for performance
    last_sbom_upload = models.DateTimeField(null=True, blank=True)
    last_scan_result = models.JSONField(null=True, blank=True, help_text="Cached scan results")
    last_metrics_sync = models.DateTimeField(null=True, blank=True)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self) -> str:
        """Return string representation."""
        return f"{self.component.name} -> {self.dt_server.name}/{self.dt_project_name}"


class VulnerabilityScanResult(models.Model):
    """
    Historical vulnerability scan results from various providers.

    Stores results for time series analysis and historical tracking.
    Supports both OSV and Dependency Track providers with consistent data structures.
    No expiration - all results are kept for historical analysis.
    """

    class Meta:
        db_table = apps.get_app_config("vulnerability_scanning").name + "_scan_results"
        indexes = [
            # Core lookup indexes
            models.Index(fields=["sbom", "provider", "created_at"]),
            models.Index(fields=["component_mapping"]),
            # Time series analysis indexes for weekly scans
            models.Index(fields=["sbom", "created_at"]),
            models.Index(fields=["provider", "created_at"]),
            models.Index(fields=["scan_trigger", "created_at"]),
            # Vulnerability severity analysis
            models.Index(fields=["total_vulnerabilities", "created_at"]),
            models.Index(fields=["critical_vulnerabilities", "created_at"]),
            # Latest scan queries
            models.Index(fields=["sbom", "provider", "-created_at"]),
        ]

        # Order by most recent first by default
        ordering = ["-created_at"]

    PROVIDER_CHOICES = [
        ("osv", "OSV Scanner"),
        ("dependency_track", "Dependency Track"),
    ]

    SCAN_TRIGGER_CHOICES = [
        ("upload", "SBOM Upload"),
        ("manual", "Manual Trigger"),
        ("weekly", "Weekly Batch"),
        ("component_latest", "Component Latest SBOM"),
        ("api", "API Request"),
    ]

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    sbom = models.ForeignKey("sboms.SBOM", on_delete=models.CASCADE, related_name="vulnerability_scan_results")
    provider = models.CharField(max_length=20, choices=PROVIDER_CHOICES)

    # Enhanced tracking
    scan_trigger = models.CharField(
        max_length=20, choices=SCAN_TRIGGER_CHOICES, default="upload", help_text="What triggered this scan"
    )

    component_mapping = models.ForeignKey(
        ComponentDependencyTrackMapping,
        on_delete=models.CASCADE,
        related_name="scan_results",
        null=True,
        blank=True,
        help_text="Only applicable for Dependency Track scans",
    )

    # Standardized scan result data
    vulnerability_count = models.JSONField(
        validators=[validate_vulnerability_count],
        help_text=("Vulnerability counts by severity: " "{total, critical, high, medium, low, info, unknown}"),
    )
    findings = models.JSONField(
        validators=[validate_findings_array],
        help_text="Standardized vulnerability findings list - direct array format for both providers",
    )
    scan_metadata = models.JSONField(
        default=dict, help_text="Provider-specific metadata (DT metrics, OSV summary, etc.)"
    )

    # Cached counts for efficient queries (denormalized for performance)
    total_vulnerabilities = models.IntegerField(default=0, help_text="Total vulnerability count")
    critical_vulnerabilities = models.IntegerField(default=0, help_text="Critical vulnerability count")
    high_vulnerabilities = models.IntegerField(default=0, help_text="High vulnerability count")
    medium_vulnerabilities = models.IntegerField(default=0, help_text="Medium vulnerability count")
    low_vulnerabilities = models.IntegerField(default=0, help_text="Low vulnerability count")

    # Lifecycle tracking (no expiration - keep all historical data)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self) -> str:
        """Return string representation."""
        return f"{self.get_provider_display()} Results for {self.sbom.name} ({self.created_at})"

    def save(self, *args, **kwargs):
        """Override save to populate denormalized fields."""
        # Extract counts from vulnerability_count JSON for efficient querying
        if self.vulnerability_count:
            self.total_vulnerabilities = self.vulnerability_count.get("total", 0)
            self.critical_vulnerabilities = self.vulnerability_count.get("critical", 0)
            self.high_vulnerabilities = self.vulnerability_count.get("high", 0)
            self.medium_vulnerabilities = self.vulnerability_count.get("medium", 0)
            self.low_vulnerabilities = self.vulnerability_count.get("low", 0)

        super().save(*args, **kwargs)

    @classmethod
    def get_time_series_data(cls, team=None, component=None, days=30) -> list[Dict[str, Any]]:
        """
        Get vulnerability time series data for charts and analysis.

        Args:
            team: Filter by team (optional)
            component: Filter by component (optional)
            days: Number of days to look back

        Returns:
            List of daily vulnerability counts
        """
        from datetime import timedelta

        from django.utils import timezone

        end_date = timezone.now().date()
        start_date = end_date - timedelta(days=days)

        queryset = cls.objects.filter(created_at__date__gte=start_date, created_at__date__lte=end_date)

        if team:
            queryset = queryset.filter(sbom__component__team=team)
        if component:
            queryset = queryset.filter(sbom__component=component)

        # Aggregate by date
        from django.db.models import Count, Sum
        from django.db.models.functions import TruncDate

        return list(
            queryset.annotate(date=TruncDate("created_at"))
            .values("date")
            .annotate(
                total_vulns=Sum("total_vulnerabilities"),
                critical_vulns=Sum("critical_vulnerabilities"),
                high_vulns=Sum("high_vulnerabilities"),
                medium_vulns=Sum("medium_vulnerabilities"),
                low_vulns=Sum("low_vulnerabilities"),
                scan_count=Count("id"),
            )
            .order_by("date")
        )

    @classmethod
    def get_latest_for_sbom(cls, sbom, provider=None):
        """Get the latest scan result for an SBOM (no expiration check)."""
        queryset = cls.objects.filter(sbom=sbom)

        if provider:
            queryset = queryset.filter(provider=provider)

        return queryset.first()  # Uses default ordering (-created_at)

    @classmethod
    def get_team_summary(cls, team, days=7) -> Dict[str, Any]:
        """Get vulnerability summary for a team over specified days."""
        from datetime import timedelta

        from django.db.models import Avg, Count, Sum
        from django.utils import timezone

        start_date = timezone.now() - timedelta(days=days)

        queryset = cls.objects.filter(sbom__component__team=team, created_at__gte=start_date)

        summary = queryset.aggregate(
            total_scans=Count("id"),
            total_vulns=Sum("total_vulnerabilities"),
            avg_vulns_per_scan=Avg("total_vulnerabilities"),
            total_critical=Sum("critical_vulnerabilities"),
            total_high=Sum("high_vulnerabilities"),
            total_medium=Sum("medium_vulnerabilities"),
            total_low=Sum("low_vulnerabilities"),
        )

        return {
            "team": team.name,
            "period_days": days,
            "scan_count": summary["total_scans"] or 0,
            "vulnerability_summary": {
                "total": summary["total_vulns"] or 0,
                "critical": summary["total_critical"] or 0,
                "high": summary["total_high"] or 0,
                "medium": summary["total_medium"] or 0,
                "low": summary["total_low"] or 0,
                "average_per_scan": round(summary["avg_vulns_per_scan"] or 0, 2),
            },
        }
