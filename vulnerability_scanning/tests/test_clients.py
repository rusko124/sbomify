"""Tests for vulnerability scanning clients using real Dependency Track API schemas."""

import json
import pytest
import uuid
from unittest.mock import Mock, patch, MagicMock
from requests.exceptions import RequestException, HTTPError
from requests import Response

from ..clients import DependencyTrackClient, DependencyTrackAPIError, OSVClient, VulnerabilityProviderError


@pytest.mark.django_db
class TestDependencyTrackClient:
    """Test DependencyTrackClient with real API schemas."""

    def test_init_client(self):
        """Test client initialization."""
        client = DependencyTrackClient("https://dt.example.com", "test-api-key")
        assert client.base_url == "https://dt.example.com"
        assert client.api_key == "test-api-key"
        assert client.timeout == 30

    def test_init_client_custom_timeout(self):
        """Test client initialization with custom timeout."""
        client = DependencyTrackClient("https://dt.example.com", "test-api-key", timeout=60)
        assert client.timeout == 60

    @patch('vulnerability_scanning.clients.DependencyTrackClient._make_request')
    def test_health_check_success(self, mock_make_request):
        """Test successful health check using readiness endpoint."""
        # Mock response based on /health/ready endpoint from DT API
        mock_make_request.return_value = {
            "status": "UP",
            "checks": [
                {"name": "database", "status": "UP"},
                {"name": "messaging", "status": "UP"}
            ]
        }

        client = DependencyTrackClient("https://dt.example.com", "test-api-key")
        result = client.health_check()

        assert result["status"] == "healthy"
        assert "details" in result
        assert result["details"]["status"] == "UP"
        mock_make_request.assert_called_once_with('GET', '/health/ready')

    @patch('vulnerability_scanning.clients.DependencyTrackClient._make_request')
    def test_health_check_failure(self, mock_make_request):
        """Test health check failure with graceful degradation."""
        # Both health endpoints fail
        mock_make_request.side_effect = DependencyTrackAPIError("Connection failed")

        client = DependencyTrackClient("https://dt.example.com", "test-api-key")
        result = client.health_check()

        # Should return unhealthy status instead of raising exception
        assert result["status"] == "unhealthy"
        assert "error" in result
        assert "Service unavailable" in str(result["error"])

        # Should try both endpoints
        assert mock_make_request.call_count == 2
        mock_make_request.assert_any_call('GET', '/health/ready')
        mock_make_request.assert_any_call('GET', '/health')

    @patch('vulnerability_scanning.clients.DependencyTrackClient._make_request')
    def test_create_project_success(self, mock_make_request):
        """Test successful project creation using real Project schema."""
        project_uuid = uuid.uuid4()

        # Mock response based on Project schema from DT API
        mock_make_request.return_value = {
            "uuid": str(project_uuid),
            "name": "Test Component",
            "version": "1.0.0",
            "description": "Test project for component scanning",
            "classifier": "APPLICATION",
            "active": True,
            "tags": [],
            "properties": [],
            "lastBomImport": None,
            "lastBomImportFormat": None,
            "lastInheritedRiskScore": 0.0,
            "metrics": {
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0,
                "unassigned": 0,
                "vulnerabilities": 0,
                "vulnerableComponents": 0,
                "components": 0,
                "suppressed": 0,
                "findingsTotal": 0,
                "findingsAudited": 0,
                "findingsUnaudited": 0,
                "inheritedRiskScore": 0.0,
                "policyViolationsFail": 0,
                "policyViolationsWarn": 0,
                "policyViolationsInfo": 0,
                "policyViolationsTotal": 0,
                "policyViolationsAudited": 0,
                "policyViolationsUnaudited": 0,
                "policyViolationsSecurityTotal": 0,
                "policyViolationsSecurityAudited": 0,
                "policyViolationsSecurityUnaudited": 0,
                "policyViolationsLicenseTotal": 0,
                "policyViolationsLicenseAudited": 0,
                "policyViolationsLicenseUnaudited": 0,
                "policyViolationsOperationalTotal": 0,
                "policyViolationsOperationalAudited": 0,
                "policyViolationsOperationalUnaudited": 0
            }
        }

        client = DependencyTrackClient("https://dt.example.com", "test-api-key")
        result = client.create_project("Test Component", "1.0.0", "Test project for component scanning")

        assert result["uuid"] == str(project_uuid)
        assert result["name"] == "Test Component"
        assert result["version"] == "1.0.0"

        expected_payload = {
            "name": "Test Component",
            "version": "1.0.0",
            "classifier": "APPLICATION",
            "description": "Test project for component scanning"
        }
        mock_make_request.assert_called_once_with(
            'PUT', '/v1/project', data=expected_payload
        )

    @patch('vulnerability_scanning.clients.DependencyTrackClient._make_request')
    def test_create_project_api_error(self, mock_make_request):
        """Test project creation API error handling."""
        mock_make_request.side_effect = DependencyTrackAPIError(
            "Invalid project name",
            status_code=400,
            response_data={"detail": "Invalid project name"}
        )

        client = DependencyTrackClient("https://dt.example.com", "test-api-key")

        with pytest.raises(DependencyTrackAPIError) as exc_info:
            client.create_project("", "1.0.0")  # Invalid empty name

        assert exc_info.value.status_code == 400
        assert "Invalid project name" in str(exc_info.value)

    @patch('vulnerability_scanning.clients.DependencyTrackClient._make_request')
    def test_upload_sbom_success(self, mock_make_request):
        """Test successful SBOM upload using real BomSubmitRequest schema."""
        # Mock response based on BomProcessingResponse schema from DT API
        mock_make_request.return_value = {
            "token": str(uuid.uuid4()),
            "processing": True
        }

        client = DependencyTrackClient("https://dt.example.com", "test-api-key")
        sbom_data = b'{"bomFormat": "CycloneDX", "specVersion": "1.5"}'
        project_uuid = uuid.uuid4()

        result = client.upload_sbom(str(project_uuid), sbom_data)

        assert "token" in result
        assert result["processing"] is True

        expected_data = {
            "project": str(project_uuid),
            "autoCreate": "true"
        }
        mock_make_request.assert_called_once()
        # Check that the call was made with POST method and correct endpoint
        call_args = mock_make_request.call_args
        assert call_args[0][0] == 'POST'  # method
        assert call_args[0][1] == '/v1/bom'  # endpoint

    @patch('vulnerability_scanning.clients.DependencyTrackClient._make_request')
    def test_get_project_metrics_success(self, mock_make_request):
        """Test successful project metrics retrieval using real ProjectMetrics schema."""
        project_uuid = uuid.uuid4()

        # Mock response based on ProjectMetrics schema from DT API
        mock_make_request.return_value = {
            "critical": 2,
            "high": 5,
            "medium": 8,
            "low": 12,
            "unassigned": 0,
            "vulnerabilities": 27,
            "vulnerableComponents": 15,
            "components": 150,
            "suppressed": 3,
            "findingsTotal": 27,
            "findingsAudited": 5,
            "findingsUnaudited": 22,
            "inheritedRiskScore": 7.2,
            "policyViolationsFail": 1,
            "policyViolationsWarn": 2,
            "policyViolationsInfo": 0,
            "policyViolationsTotal": 3,
            "policyViolationsAudited": 1,
            "policyViolationsUnaudited": 2,
            "policyViolationsSecurityTotal": 2,
            "policyViolationsSecurityAudited": 1,
            "policyViolationsSecurityUnaudited": 1,
            "policyViolationsLicenseTotal": 1,
            "policyViolationsLicenseAudited": 0,
            "policyViolationsLicenseUnaudited": 1,
            "policyViolationsOperationalTotal": 0,
            "policyViolationsOperationalAudited": 0,
            "policyViolationsOperationalUnaudited": 0
        }

        client = DependencyTrackClient("https://dt.example.com", "test-api-key")
        result = client.get_project_metrics(str(project_uuid))

        assert result["vulnerabilities"] == 27
        assert result["critical"] == 2
        assert result["high"] == 5
        assert result["inheritedRiskScore"] == 7.2

        mock_make_request.assert_called_once_with(
            'GET', f'/v1/metrics/project/{project_uuid}/current'
        )

    @patch('vulnerability_scanning.clients.DependencyTrackClient._make_paginated_request')
    def test_get_project_vulnerabilities_success(self, mock_make_paginated_request):
        """Test successful project vulnerabilities retrieval using real Finding schema."""
        project_uuid = uuid.uuid4()

        # Mock response based on Finding schema from DT API with pagination metadata
        mock_make_paginated_request.return_value = {
            "content": [
            {
                "component": {
                    "uuid": str(uuid.uuid4()),
                    "group": "org.apache.logging.log4j",
                    "name": "log4j-core",
                    "version": "2.14.1",
                    "classifier": "LIBRARY",
                    "filename": "log4j-core-2.14.1.jar",
                    "extension": "jar",
                    "md5": "abc123",
                    "sha1": "def456",
                    "sha256": "ghi789",
                    "sha512": "jkl012",
                    "purl": "pkg:maven/org.apache.logging.log4j/log4j-core@2.14.1",
                    "cpe": "cpe:2.3:a:apache:log4j:2.14.1:*:*:*:*:*:*:*"
                },
                "vulnerability": {
                    "uuid": str(uuid.uuid4()),
                    "vulnId": "CVE-2021-44228",
                    "source": "NVD",
                    "title": "Apache Log4j2 JNDI features used in configuration, log messages, and parameters do not protect against attacker controlled LDAP and other JNDI related endpoints",
                    "subtitle": "",
                    "description": "Apache Log4j2 2.0-beta9 through 2.15.0 (excluding security releases 2.12.2, 2.12.3, and 2.3.1) JNDI features used in configuration, log messages, and parameters do not protect against attacker controlled LDAP and other JNDI related endpoints. An attacker who can control log messages or log message parameters can execute arbitrary code loaded from LDAP servers when message lookup substitution is enabled. From log4j 2.15.0, this behavior has been disabled by default.",
                    "recommendation": "Upgrade to Apache Log4j 2.16.0 or later",
                    "references": "https://nvd.nist.gov/vuln/detail/CVE-2021-44228",
                    "created": "2021-12-10T10:15:09.000+0000",
                    "published": "2021-12-10T10:15:09.000+0000",
                    "updated": "2021-12-14T12:30:15.000+0000",
                    "severity": "CRITICAL",
                    "cvssV2BaseScore": 10.0,
                    "cvssV2ImpactSubScore": 10.0,
                    "cvssV2ExploitabilitySubScore": 10.0,
                    "cvssV2Vector": "AV:N/AC:L/Au:N/C:C/I:C/A:C",
                    "cvssV3BaseScore": 10.0,
                    "cvssV3ImpactSubScore": 6.0,
                    "cvssV3ExploitabilitySubScore": 3.9,
                    "cvssV3Vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
                    "owaspRRLikelihoodScore": 5.0,
                    "owaspRRTechnicalImpactScore": 9.0,
                    "owaspRRBusinessImpactScore": 3.0
                },
                "analysis": {
                    "state": "NOT_AFFECTED",
                    "isSuppressed": False,
                    "response": "WILL_NOT_FIX",
                    "detail": "This vulnerability does not affect our usage of log4j"
                },
                "matrix": str(uuid.uuid4())
            }
            ],
            "totalElements": 1,
            "paginated": True
        }

        client = DependencyTrackClient("https://dt.example.com", "test-api-key")
        result = client.get_project_vulnerabilities(str(project_uuid))

        assert result["totalElements"] == 1
        assert len(result["content"]) == 1
        assert result["content"][0]["vulnerability"]["vulnId"] == "CVE-2021-44228"
        assert result["content"][0]["vulnerability"]["severity"] == "CRITICAL"
        assert result["content"][0]["component"]["name"] == "log4j-core"

        mock_make_paginated_request.assert_called_once_with(
            f'/v1/finding/project/{project_uuid}', {'suppressed': 'false'}, None, None
        )


@pytest.mark.django_db
class TestOSVClient:
    """Test OSVClient functionality."""

    def test_init_client(self):
        """Test OSV client initialization."""
        client = OSVClient()
        assert client.timeout == 300
        assert client.scanner_path == "/usr/local/bin/osv-scanner"

    def test_init_client_custom_timeout(self):
        """Test OSV client with custom timeout."""
        client = OSVClient(timeout=120)
        assert client.timeout == 120

    @patch('subprocess.run')
    def test_scan_sbom_success(self, mock_run):
        """Test successful OSV SBOM scan."""
        # Mock OSV scanner output based on real OSV format
        mock_output = {
            "results": [
                {
                    "source": {
                        "path": "test-sbom.json",
                        "type": "cyclone-dx"
                    },
                    "packages": [
                        {
                            "package": {
                                "name": "log4j-core",
                                "version": "2.14.1",
                                "ecosystem": "Maven"
                            },
                            "vulnerabilities": [
                                {
                                    "id": "CVE-2021-44228",
                                    "summary": "Remote code execution in Log4j",
                                    "details": "Apache Log4j2 <=2.14.1 JNDI features do not protect against attacker controlled LDAP and other JNDI related endpoints.",
                                    "severity": [
                                        {
                                            "type": "CVSS_V3",
                                            "score": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H"
                                        }
                                    ],
                                    "affected": [
                                        {
                                            "package": {
                                                "name": "log4j-core",
                                                "ecosystem": "Maven"
                                            },
                                            "ranges": [
                                                {
                                                    "type": "ECOSYSTEM",
                                                    "events": [
                                                        {"introduced": "2.0-beta9"},
                                                        {"fixed": "2.16.0"}
                                                    ]
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                }
            ]
        }

        mock_process = Mock()
        mock_process.returncode = 0
        mock_process.stdout = json.dumps(mock_output)
        mock_process.stderr = ""
        mock_run.return_value = mock_process

        client = OSVClient()
        sbom_data = b'{"bomFormat": "CycloneDX", "specVersion": "1.5"}'

        result = client.scan_sbom(sbom_data, "test-sbom.json")

        assert "vulnerability_count" in result
        assert "findings" in result
        assert result["vulnerability_count"]["total"] == 1
        # OSV client maps CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H to critical severity
        assert result["vulnerability_count"]["critical"] == 1
        assert len(result["findings"]["vulnerabilities"]) == 1

        vulnerability = result["findings"]["vulnerabilities"][0]
        assert vulnerability["id"] == "CVE-2021-44228"
        assert vulnerability["severity"] == "critical"
        assert vulnerability["package_name"] == "log4j-core"

    @patch('subprocess.run')
    def test_scan_sbom_no_vulnerabilities(self, mock_run):
        """Test OSV scan with no vulnerabilities found."""
        mock_output = {
            "results": [
                {
                    "source": {
                        "path": "test-sbom.json",
                        "type": "cyclone-dx"
                    },
                    "packages": []
                }
            ]
        }

        mock_process = Mock()
        mock_process.returncode = 0
        mock_process.stdout = json.dumps(mock_output)
        mock_process.stderr = ""
        mock_run.return_value = mock_process

        client = OSVClient()
        sbom_data = b'{"bomFormat": "CycloneDX", "specVersion": "1.5"}'

        result = client.scan_sbom(sbom_data)

        assert result["vulnerability_count"]["total"] == 0
        assert result["vulnerability_count"]["critical"] == 0
        assert result["vulnerability_count"]["high"] == 0
        assert len(result["findings"]["vulnerabilities"]) == 0

    @patch('subprocess.run')
    def test_scan_sbom_scanner_error(self, mock_run):
        """Test OSV scanner error handling."""
        mock_process = Mock()
        mock_process.returncode = 1
        mock_process.stdout = ""
        mock_process.stderr = "Error: Invalid SBOM format"
        mock_run.return_value = mock_process

        client = OSVClient()
        sbom_data = b'invalid json'

        with pytest.raises(VulnerabilityProviderError) as exc_info:
            client.scan_sbom(sbom_data)

        assert "OSV scan failed" in str(exc_info.value)

    @patch('subprocess.run')
    def test_scan_sbom_timeout(self, mock_run):
        """Test OSV scanner timeout handling."""
        mock_run.side_effect = TimeoutError("Scanner timed out")

        client = OSVClient(timeout=1)
        sbom_data = b'{"bomFormat": "CycloneDX"}'

        with pytest.raises(VulnerabilityProviderError) as exc_info:
            client.scan_sbom(sbom_data)

        assert "Scanner timed out" in str(exc_info.value)

    def test_determine_file_suffix(self):
        """Test file suffix determination for OSV scanner compatibility (NOT format detection)."""
        client = OSVClient()

        # Test CycloneDX content -> .cdx.json suffix
        cyclonedx_data = b'{"bomFormat": "CycloneDX", "specVersion": "1.5"}'
        assert client._determine_file_suffix(cyclonedx_data) == ".cdx.json"

        # Test SPDX content -> .spdx.json suffix
        spdx_data = b'{"spdxVersion": "SPDX-2.3", "SPDXID": "SPDXRef-DOCUMENT"}'
        assert client._determine_file_suffix(spdx_data) == ".spdx.json"

        # Test unknown content -> .json suffix
        unknown_data = b'{"unknown": "format"}'
        assert client._determine_file_suffix(unknown_data) == ".json"

        # Test invalid JSON -> .json suffix
        invalid_data = b'invalid json content'
        assert client._determine_file_suffix(invalid_data) == ".json"

    def test_detect_sbom_format(self):
        """Test SBOM format detection - CRITICAL: Only uses content, never filenames."""
        client = OSVClient()

        # Test CycloneDX detection
        cyclonedx_data = b'{"bomFormat": "CycloneDX", "specVersion": "1.5"}'
        assert client.detect_sbom_format(cyclonedx_data) == "cyclonedx"

        # Test SPDX detection
        spdx_data = b'{"spdxVersion": "SPDX-2.3", "SPDXID": "SPDXRef-DOCUMENT"}'
        assert client.detect_sbom_format(spdx_data) == "spdx"

        # Test unknown format
        unknown_data = b'{"someOtherField": "value"}'
        assert client.detect_sbom_format(unknown_data) == "unknown"

        # Test invalid JSON
        invalid_data = b'invalid json content'
        assert client.detect_sbom_format(invalid_data) == "unknown"

        # Test empty content
        empty_data = b''
        assert client.detect_sbom_format(empty_data) == "unknown"

    def test_map_osv_severity(self):
        """Test OSV severity mapping with vulnerability dict."""
        client = OSVClient()

        # Test with a vulnerability dict containing severity info
        vuln_with_cvss = {
            "severity": [
                {
                    "type": "CVSS_V3",
                    "score": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H"
                }
            ]
        }
        assert client._map_osv_severity(vuln_with_cvss) == "critical"

        # Test with no severity info
        vuln_no_severity = {
            "affected": []
        }
        assert client._map_osv_severity(vuln_no_severity) == "medium"