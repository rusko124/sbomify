"""
Integration tests for vulnerability scanning service.

Tests both OSV and Dependency Track provider integration end-to-end.
"""
import json
import uuid
from unittest.mock import Mock, patch
import pytest
from django.utils import timezone

from vulnerability_scanning.services import VulnerabilityScanningService
from vulnerability_scanning.models import DependencyTrackServer, TeamVulnerabilitySettings
from vulnerability_scanning.clients import OSVClient, DependencyTrackClient


@pytest.mark.django_db
class TestVulnerabilityScanningIntegration:
    """Integration tests for vulnerability scanning service."""

    @pytest.fixture
    def sample_sbom_data(self):
        """Sample CycloneDX SBOM data for testing."""
        return json.dumps({
            "bomFormat": "CycloneDX",
            "specVersion": "1.5",
            "components": [
                {
                    "type": "library",
                    "name": "express",
                    "version": "4.17.1",
                    "purl": "pkg:npm/express@4.17.1"
                }
            ]
        }).encode('utf-8')

    @pytest.fixture
    def spdx_sbom_data(self):
        """Sample SPDX SBOM data for testing."""
        return json.dumps({
            "spdxVersion": "SPDX-2.3",
            "dataLicense": "CC0-1.0",
            "SPDXID": "SPDXRef-DOCUMENT",
            "packages": [
                {
                    "name": "express",
                    "versionInfo": "4.17.1",
                    "SPDXID": "SPDXRef-Package-express"
                }
            ]
        }).encode('utf-8')

    @pytest.fixture
    def real_team(self, db):
        """Create a real team instance for testing."""
        from teams.models import Team, Member
        from core.models import User

        user = User.objects.create_user(
            username="testuser",
            email="test@example.com",
            password="testpass123"
        )

        team = Team.objects.create(
            key="test-team",
            name="Test Team",
            billing_plan="business"
        )

        Member.objects.create(
            team=team,
            user=user,
            role="admin"
        )

        return team

    @pytest.fixture
    def real_component(self, real_team, db):
        """Create a real component instance for testing."""
        from core.models import Component

        return Component.objects.create(
            name="test-component",
            team=real_team,
            component_type="sbom"
        )

    @pytest.fixture
    def real_sbom(self, real_component, db):
        """Create a real SBOM instance for testing."""
        from sboms.models import SBOM

        return SBOM.objects.create(
            component=real_component,
            sbom_filename="test.json",
            name="Test SBOM"
        )

    @pytest.fixture
    def dt_server(self, db):
        """Create a test DT server."""
        return DependencyTrackServer.objects.create(
            name="Test DT Server",
            url="https://dt.test.com",
            api_key="test-api-key",
            max_concurrent_scans=500,
            is_active=True,
            health_status="healthy"
        )

    def test_osv_scanning_integration(self, real_sbom, spdx_sbom_data):
        """Test OSV scanning integration with SPDX format."""
        service = VulnerabilityScanningService()

        # Mock OSV client response
        mock_osv_response = {
            "vulnerability_count": {
                "total": 2,
                "critical": 0,
                "high": 1,
                "medium": 1,
                "low": 0,
                "info": 0
            },
            "findings": [
                {
                    "id": "GHSA-abc123",
                    "severity": "HIGH",
                    "title": "Test vulnerability",
                    "component": {
                        "name": "express",
                        "version": "4.17.1",
                        "ecosystem": "npm"
                    }
                }
            ],
            "provider": "osv"
        }

        with patch.object(service.osv_client, 'scan_sbom', return_value=mock_osv_response), \
             patch.object(service, '_get_cached_osv_results', return_value=None), \
             patch.object(service, '_cache_osv_results') as mock_cache:

            # Execute the scan - SPDX should always use OSV
            result = service.scan_sbom_for_vulnerabilities(real_sbom, spdx_sbom_data, "test")

            # Verify OSV was used
            service.osv_client.scan_sbom.assert_called_once_with(spdx_sbom_data, "test.json")

            # Verify results are properly formatted
            assert result["provider"] == "osv"
            assert result["vulnerability_count"]["total"] == 2
            assert result["vulnerability_count"]["high"] == 1
            assert len(result["findings"]) == 1
            assert result["sbom_id"] == str(real_sbom.id)

            # Verify caching was called
            mock_cache.assert_called_once()

    def test_dependency_track_scanning_integration(self, real_sbom, sample_sbom_data, dt_server, db):
        """Test Dependency Track scanning integration."""
        service = VulnerabilityScanningService()

        # Create team vulnerability settings for DT
        team_settings = TeamVulnerabilitySettings.objects.create(
            team=real_sbom.component.team,
            vulnerability_provider="dependency_track"
        )

        # Mock DT responses
        mock_dt_response = {
            "vulnerability_count": {
                "total": 3,
                "critical": 1,
                "high": 1,
                "medium": 1,
                "low": 0,
                "info": 0
            },
            "findings": [
                {
                    "id": "CVE-2023-1234",
                    "severity": "CRITICAL",
                    "title": "Critical vulnerability",
                    "component": {
                        "name": "express",
                        "version": "4.17.1",
                        "ecosystem": "npm"
                    }
                }
            ],
            "provider": "dependency_track"
        }

        with patch.object(service, 'should_use_dependency_track', return_value=True), \
             patch.object(service, '_scan_with_dependency_track', return_value=mock_dt_response) as mock_dt_scan:

            # Execute the scan
            result = service.scan_sbom_for_vulnerabilities(real_sbom, sample_sbom_data, "test")

            # Verify DT was used
            mock_dt_scan.assert_called_once_with(real_sbom, sample_sbom_data)

            # Verify results are properly formatted
            assert result["provider"] == "dependency_track"
            assert result["vulnerability_count"]["total"] == 3
            assert result["vulnerability_count"]["critical"] == 1
            assert len(result["findings"]) == 1
            assert result["sbom_id"] == str(real_sbom.id)

    def test_dt_scan_counter_management(self, real_sbom, sample_sbom_data, dt_server, db):
        """Test that DT scanning properly manages scan counters."""
        from vulnerability_scanning.models import ComponentDependencyTrackMapping

        service = VulnerabilityScanningService()

        # Create a mapping
        mapping = ComponentDependencyTrackMapping.objects.create(
            component=real_sbom.component,
            dt_server=dt_server,
            dt_project_uuid=str(uuid.uuid4()),
            dt_project_name="test-project"
        )

        # Mock DT client responses
        mock_metrics = {"componentCount": 10, "vulnerabilityCount": 5}
        mock_vulnerabilities = {
            "content": [
                {
                    "component": {"name": "express", "version": "4.17.1"},
                    "vulnerability": {"vulnId": "CVE-2023-1234", "severity": "HIGH"}
                }
            ]
        }

        initial_count = dt_server.current_scan_count

        with patch('vulnerability_scanning.services.DependencyTrackClient') as mock_client_class:
            mock_client = Mock()
            mock_client_class.return_value = mock_client
            mock_client.get_project_metrics.return_value = mock_metrics
            mock_client.get_project_vulnerabilities.return_value = mock_vulnerabilities

            with patch.object(service, '_get_cached_dt_results', return_value=None), \
                 patch.object(service, '_cache_dt_results'), \
                 patch.object(service, '_process_dt_results', return_value={"vulnerability_count": {"total": 1}, "findings": []}):

                # Execute the scan
                result = service.get_dependency_track_results(real_sbom, mapping, force_refresh=True)

                # Verify scan counter was incremented and then decremented
                dt_server.refresh_from_db()
                assert dt_server.current_scan_count == initial_count  # Should be back to original

    def test_dt_scan_counter_management_on_error(self, real_sbom, sample_sbom_data, dt_server, db):
        """Test that DT scan counters are properly decremented even on errors."""
        from vulnerability_scanning.models import ComponentDependencyTrackMapping
        from vulnerability_scanning.clients import DependencyTrackAPIError

        service = VulnerabilityScanningService()

        # Create a mapping
        mapping = ComponentDependencyTrackMapping.objects.create(
            component=real_sbom.component,
            dt_server=dt_server,
            dt_project_uuid=str(uuid.uuid4()),
            dt_project_name="test-project"
        )

        initial_count = dt_server.current_scan_count

        with patch('vulnerability_scanning.services.DependencyTrackClient') as mock_client_class:
            mock_client = Mock()
            mock_client_class.return_value = mock_client
            mock_client.get_project_metrics.side_effect = DependencyTrackAPIError("Test error")

            with patch.object(service, '_get_cached_dt_results', return_value=None), \
                 pytest.raises(Exception):  # Should raise VulnerabilityProviderError

                # Execute the scan (should fail)
                service.get_dependency_track_results(real_sbom, mapping, force_refresh=True)

        # Verify scan counter was decremented even on error
        dt_server.refresh_from_db()
        assert dt_server.current_scan_count == initial_count  # Should be back to original

    def test_provider_routing_logic(self, real_sbom, sample_sbom_data, spdx_sbom_data, dt_server, db):
        """Test that provider routing works correctly based on team settings."""
        service = VulnerabilityScanningService()

        # Test 1: No settings = OSV (uses SPDX format)
        with patch.object(service, '_scan_with_osv') as mock_osv, \
             patch.object(service, '_scan_with_dependency_track') as mock_dt:

            mock_osv.return_value = {"provider": "osv", "vulnerability_count": {"total": 0}, "findings": []}

            result = service.scan_sbom_for_vulnerabilities(real_sbom, spdx_sbom_data, "test")

            mock_osv.assert_called_once()
            mock_dt.assert_not_called()
            assert result["provider"] == "osv"

        # Test 2: DT settings with CycloneDX = DT
        team_settings, _ = TeamVulnerabilitySettings.objects.get_or_create(
            team=real_sbom.component.team,
            defaults={"vulnerability_provider": "osv"}
        )
        # Update the settings to use DT
        team_settings.vulnerability_provider = "dependency_track"
        team_settings.save()

        with patch.object(service, '_scan_with_osv') as mock_osv, \
             patch.object(service, '_scan_with_dependency_track') as mock_dt:

            mock_dt.return_value = {"provider": "dependency_track", "vulnerability_count": {"total": 0}, "findings": []}

            result = service.scan_sbom_for_vulnerabilities(real_sbom, sample_sbom_data, "test")

            mock_osv.assert_not_called()
            mock_dt.assert_called_once()
            assert result["provider"] == "dependency_track"

        # Test 3: DT settings with SPDX = OSV (forced fallback)
        with patch.object(service, '_scan_with_osv') as mock_osv, \
             patch.object(service, '_scan_with_dependency_track') as mock_dt:

            mock_osv.return_value = {"provider": "osv", "vulnerability_count": {"total": 0}, "findings": []}

            result = service.scan_sbom_for_vulnerabilities(real_sbom, spdx_sbom_data, "test")

            mock_osv.assert_called_once()
            mock_dt.assert_not_called()
            assert result["provider"] == "osv"

    def test_standardized_results_format(self, real_sbom, spdx_sbom_data):
        """Test that both providers return standardized result formats."""
        service = VulnerabilityScanningService()

        # Test OSV results with SPDX (forces OSV)
        with patch.object(service, '_scan_with_osv') as mock_osv:
            mock_osv.return_value = {
                "vulnerability_count": {"total": 1, "high": 1},
                "findings": [{"id": "test", "severity": "high"}],
                "provider": "osv"
            }

            result = service.scan_sbom_for_vulnerabilities(real_sbom, spdx_sbom_data, "test")

            # Verify standardized format
            assert "vulnerability_count" in result
            assert "findings" in result
            assert "provider" in result
            assert "sbom_id" in result
            assert "scan_timestamp" in result

            # Verify vulnerability count structure
            vuln_count = result["vulnerability_count"]
            required_keys = {"total", "critical", "high", "medium", "low", "info", "unknown"}
            assert set(vuln_count.keys()) >= required_keys
